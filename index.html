<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2E8B57">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Music Player">
    <!-- <link rel="manifest" href="manifest.json"> -->
    <!-- Note: Upload manifest.json file to your server to enable PWA features -->
    <link rel="icon" type="image/svg+xml" href="icon-final.svg">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Music Player</title>
    
    <!-- VConsole Mobile DevTools (Alternative to Eruda) -->
    <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
    <script>
        var vConsole = new window.VConsole();
        console.log('ðŸ”§ VConsole loaded! Look for green button in bottom-right.');
    </script>
    
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        html, body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            touch-action: manipulation; /* Prevent double-tap zoom */
            -webkit-text-size-adjust: 100%; /* Prevent text scaling on orientation change */
            width: 100%;
            height: 100%;
            position: fixed; /* Prevent scroll bounce */
        }
        
        /* Backgrounds - PURE BLACK for dark mode */
        .bg-dark { 
            background: #000000; 
            color: #ffffff;
        }
        .bg-dark * {
            color: #ffffff;
        }
        .bg-light { 
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 50%, #d4d4d4 100%); 
            color: #000000;
        }
        .bg-light * {
            color: #000000;
        }
        .sidebar-dark { 
            background: #000000; 
            border-right: 1px solid rgba(255, 255, 255, 0.15); 
        }
        .sidebar-light { 
            background: linear-gradient(180deg, #ffffff 0%, #f8f8f8 100%); 
            border-right: 1px solid rgba(0, 0, 0, 0.05); 
        }
        
        /* Cards - Higher contrast for dark mode */
        .card-dark { 
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: #ffffff;
        }
        .card-light { 
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        /* Playlist Grid Cards */
        .playlist-grid-card {
            padding: 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 140px;
            position: relative;
        }
        .playlist-grid-card:hover {
            transform: translateY(-4px);
        }
        
        .playlist-grid-card .grid-menu-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .playlist-grid-card:hover .grid-menu-btn {
            opacity: 1;
        }
        
        /* Buttons - Brighter for dark mode */
        .btn-primary {
            background: linear-gradient(135deg, #1DB954 0%, #1ed760 100%);
            box-shadow: 0 4px 15px rgba(29, 185, 84, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            color: white;
            font-weight: 600;
            cursor: pointer;
            padding: 12px 28px;
            border-radius: 50px;
            font-size: 15px;
        }
        .btn-primary:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(29, 185, 84, 0.5); 
        }
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            transition: all 0.3s;
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            padding: 12px 28px;
            border-radius: 50px;
            font-size: 15px;
        }
        .btn-secondary:hover { 
            background: rgba(255, 255, 255, 0.22); 
            transform: translateY(-1px); 
        }
        
        .icon-btn {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            color: #ffffff;
        }
        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.22);
            transform: scale(1.1);
        }
        .icon-btn:active {
            transform: scale(0.95);
        }
        
        .icon-btn-small {
            width: 32px;
            height: 32px;
        }
        
        /* Light mode icon colors - BLACK icons in light mode */
        .bg-light .icon-btn {
            background: rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.15);
            color: #000000;
        }
        .bg-light .icon-btn:hover {
            background: rgba(0, 0, 0, 0.15);
        }
        .bg-light .icon-btn svg {
            color: #000000;
            stroke: #000000;
        }
        .bg-light .btn-secondary {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #000000 !important;
        }
        .bg-light .btn-secondary:hover {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.3);
        }
        
        /* Buttons and labels inside light mode modals */
        .modal-light .btn-secondary {
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
            color: #000000 !important;
        }
        .modal-light label.btn-secondary {
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
            color: #000000 !important;
        }
        
        /* Layout */
        .container { 
            display: flex; 
            height: 100vh; 
            overflow: hidden; 
        }
        .sidebar { 
            width: 260px; 
            padding: 24px; 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            overflow-y: auto; 
        }
        .main { 
            flex: 1; 
            overflow-y: auto; 
            padding-bottom: 140px; 
        }
        
        /* Text - Pure white for dark mode */
        .bg-dark .text-muted-dark { color: #b3b3b3; }
        .bg-light .text-muted-light { color: #6b7280; }
        
        .bg-dark input,
        .bg-dark button,
        .bg-dark .icon-btn,
        .bg-dark svg {
            color: #ffffff;
        }
        
        .bg-light input,
        .bg-light button,
        .bg-light .icon-btn,
        .bg-light svg {
            color: #000000;
        }
        
        /* Utilities */
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-2 { gap: 8px; }
        .gap-3 { gap: 12px; }
        .gap-4 { gap: 16px; }
        .p-3 { padding: 12px; }
        .p-4 { padding: 16px; }
        .p-6 { padding: 24px; }
        .p-8 { padding: 32px; }
        .mb-2 { margin-bottom: 8px; }
        .mb-4 { margin-bottom: 16px; }
        .mb-6 { margin-bottom: 24px; }
        .rounded-lg { border-radius: 12px; }
        .rounded-xl { border-radius: 16px; }
        .rounded-full { border-radius: 9999px; }
        .font-bold { font-weight: 700; }
        .text-xl { font-size: 20px; line-height: 1.4; }
        .text-2xl { font-size: 24px; line-height: 1.3; }
        .text-3xl { font-size: 30px; line-height: 1.2; }
        .text-sm { font-size: 14px; }
        .text-xs { font-size: 12px; }
        .truncate { 
            overflow: hidden; 
            text-overflow: ellipsis; 
            white-space: nowrap; 
        }
        .cursor-pointer { cursor: pointer; }
        .transition { transition: all 0.2s; }
        
        /* Input */
        input[type="text"], 
        input[type="search"] {
            width: 100%;
            padding: 12px 16px;
            border-radius: 12px;
            border: none;
            outline: none;
            font-size: 14px;
        }
        
        .bg-dark input[type="text"],
        .bg-dark input[type="search"] {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
        }
        .bg-dark input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .bg-light input[type="text"],
        .bg-light input[type="search"] {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1a1a1a;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { 
            background: rgba(255,255,255,0.3); 
            border-radius: 4px; 
        }
        ::-webkit-scrollbar-thumb:hover { 
            background: rgba(255,255,255,0.4); 
        }
        
        /* Playlist item with drag handle */
        .playlist-item { 
            padding: 14px; 
            border-radius: 12px; 
            cursor: grab;
            transition: all 0.2s; 
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            color: #ffffff;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .playlist-item:active {
            cursor: grabbing;
        }
        .playlist-item:hover { 
            transform: translateX(4px); 
        }
        .playlist-item.active { 
            border-left: 4px solid #1DB954; 
            padding-left: 10px;
        }
        .playlist-item.dragging {
            opacity: 0.5;
        }
        
        .drag-handle {
            color: rgba(255, 255, 255, 0.4);
            font-size: 18px;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        
        /* Light mode drag handles */
        .bg-light .drag-handle {
            color: rgba(0, 0, 0, 0.3);
        }
        .bg-light .drag-handle:hover {
            color: rgba(0, 0, 0, 0.5);
        }
        
        /* Song item with drag */
        .song-item { 
            padding: 16px; 
            border-radius: 12px; 
            cursor: pointer; 
            transition: all 0.2s; 
            display: flex; 
            align-items: center; 
            gap: 16px; 
            color: #ffffff;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .song-item:hover { 
            transform: scale(1.01); 
        }
        .song-item.active { 
            background: rgba(29, 185, 84, 0.15) !important; 
        }
        .song-item.dragging {
            opacity: 0.5;
        }
        
        /* Modal */
        .modal-overlay { 
            position: fixed; 
            inset: 0; 
            background: rgba(0,0,0,0.85); 
            backdrop-filter: blur(8px); 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            z-index: 1000;
            padding: 20px;
        }
        
        .modal { 
            padding: 28px; 
            border-radius: 16px; 
            width: 100%; 
            max-width: 420px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-dark {
            background: rgba(30, 30, 40, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }
        
        .modal-light {
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1a1a1a;
        }
        
        /* Context Menu */
        .context-menu {
            position: absolute;
            background: rgba(40, 40, 50, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 8px;
            padding: 8px;
            z-index: 100;
            min-width: 160px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        }
        
        .context-menu-item {
            padding: 10px 14px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ffffff;
        }
        
        .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* Player - IMPROVED */
        .player { 
            position: fixed; 
            bottom: 0; 
            left: 0; 
            right: 0; 
            padding: 12px 20px; 
            z-index: 50;
            background: #2a2a2a !important;
        }
        
        .bg-light .player {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
        }
        
        /* Player bar buttons in light mode - keep BLACK */
        .bg-light .player .icon-btn {
            color: #000000 !important;
        }
        .bg-light .player .icon-btn svg {
            color: #000000 !important;
            stroke: #000000 !important;
            fill: #000000 !important;
        }
        .bg-light .player button {
            color: #000000 !important;
        }
        .bg-light .player button svg {
            color: #000000 !important;
            stroke: #000000 !important;
            fill: #000000 !important;
        }
        
        /* Player bar text (song name, time) - make WHITE in light mode */
        .bg-light .player .player-info {
            color: #ffffff !important;
        }
        .bg-light .player .player-info * {
            color: #ffffff !important;
        }
        
        /* Volume icon - make WHITE in light mode */
        .bg-light .player .player-volume svg {
            color: #ffffff !important;
            stroke: #ffffff !important;
            fill: #ffffff !important;
        }
        
        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .player-main {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }
        
        .progress-bar { 
            height: 6px; 
            background: rgba(255,255,255,0.25); 
            border-radius: 3px; 
            cursor: pointer; 
            position: relative;
            flex: 1;
        }
        
        .progress-fill { 
            height: 100%; 
            background: #1DB954; 
            border-radius: 3px; 
            transition: width 0.1s linear;
        }
        
        /* Debug Panel */
        .debug-panel {
            position: fixed;
            bottom: 120px;
            right: 20px;
            background: rgba(30, 30, 40, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 16px;
            color: #ffffff;
            font-size: 12px;
            max-width: 300px;
            z-index: 1001;
            font-family: 'Courier New', monospace;
        }
        
        .debug-toggle {
            position: fixed;
            bottom: 120px;
            right: 20px;
            z-index: 1002;
        }
        
        /* Mobile */
        @media (max-width: 768px) {
            .sidebar { 
                position: fixed; 
                left: -100%; 
                top: 0; 
                bottom: 0; 
                z-index: 60; 
                width: 80%; 
                max-width: 300px; 
                transition: left 0.3s; 
            }
            .sidebar.open { left: 0; }
            
            .mobile-header { 
                display: flex; 
                position: relative;
                padding: 16px 20px; 
                align-items: center; 
                gap: 16px; 
                z-index: 10;
                background: inherit;
            }
            
            .overlay { 
                display: none; 
                position: fixed; 
                inset: 0; 
                background: rgba(0,0,0,0.6); 
                z-index: 50; 
            }
            .overlay.open { display: block; }
            
            .main { padding-bottom: 200px; }
            
            .btn-primary, .btn-secondary {
                padding: 10px 18px;
                font-size: 13px;
            }
            
            .icon-btn {
                width: 36px;
                height: 36px;
            }
            
            .player {
                padding: 10px 16px;
            }
            
            .player-controls {
                gap: 6px;
            }
            
            .player-main {
                flex-direction: column;
                gap: 12px;
            }
            
            .hide-mobile {
                display: none !important;
            }
            
            .debug-panel {
                bottom: 200px;
                right: 10px;
                max-width: 250px;
                font-size: 10px;
            }
            
            .debug-toggle {
                bottom: 200px;
                right: 10px;
            }
            
            .playlist-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 12px;
            }
            
            .playlist-grid-card {
                padding: 12px;
                min-width: 100px;
            }
            
            .playlist-grid-card > div:first-of-type {
                font-size: 32px !important;
                margin-bottom: 8px !important;
            }
            
            .playlist-grid-card .font-bold {
                font-size: 13px !important;
            }
            
            .playlist-grid-card .text-sm {
                font-size: 11px !important;
            }
            
            /* Guest mode warning box - wider on mobile */
            .guest-warning-box {
                max-width: 95% !important;
                padding: 18px 20px !important;
            }
        }
        
        @media (min-width: 769px) {
            .mobile-header { display: none; }
        }
        
        /* Offline indicator */
        .offline-banner {
            background: rgba(255, 152, 0, 0.95);
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
        }
        
        /* Grid layout */
        .playlist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: #000000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            color: #ffffff;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #1DB954;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { 
                opacity: 1;
                transform: scale(1);
            }
            50% { 
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
    </style>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>

</head>
<body>
    <div id="root"></div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    
    <!-- React -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script>
        const { useState, useEffect, useRef } = React;
        const PRIMARY = '#1DB954';

        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        // TODO: Replace with your Firebase config from Firebase Console
        // Instructions: See FIREBASE_SETUP_INSTRUCTIONS.md
        const firebaseConfig = {
          apiKey: "AIzaSyAA6AeCrTWe8_8sYTdnHffNuaPbbmUIftQ",
          authDomain: "fan-bai-song-player.firebaseapp.com",
          databaseURL: "https://fan-bai-song-player-default-rtdb.firebaseio.com",
          projectId: "fan-bai-song-player",
          storageBucket: "fan-bai-song-player.firebasestorage.app",
          messagingSenderId: "929176647542",
          appId: "1:929176647542:web:d0a385183a71ca358fec57"
        };

        // Initialize Firebase
        let firebaseApp, firebaseDB, firebaseAuth;
        let isFirebaseConfigured = false;

        try {
            // Check if config is filled in
            if (firebaseConfig.apiKey !== "YOUR_API_KEY_HERE") {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                firebaseDB = firebase.database();
                firebaseAuth = firebase.auth();
                isFirebaseConfigured = true;
                console.log('âœ… Firebase initialized successfully');
            } else {
                console.warn('âš ï¸ Firebase not configured. Please add your Firebase config.');
                console.warn('ðŸ“– See instructions at the top of this file');
            }
        } catch (error) {
            console.error('âŒ Firebase initialization error:', error);
            isFirebaseConfigured = false;
        }

        // ============================================
        // FIREBASE DATABASE HELPERS
        // ============================================
        const FirebaseDB = {
            // Save playlist to Firebase
            async savePlaylist(userId, playlistId, playlistData) {
                if (!isFirebaseConfigured) return;
                try {
                    await firebaseDB.ref(`users/${userId}/playlists/${playlistId}`).set({
                        name: playlistData.name,
                        createdAt: playlistData.createdAt || Date.now(),
                        updatedAt: Date.now()
                    });
                    console.log('âœ… Playlist saved to Firebase:', playlistData.name);
                } catch (error) {
                    console.error('âŒ Error saving playlist:', error);
                    throw error;
                }
            },

            // Save song to Firebase
            async saveSong(userId, playlistId, songId, songData) {
                if (!isFirebaseConfigured) return;
                try {
                    await firebaseDB.ref(`users/${userId}/playlists/${playlistId}/songs/${songId}`).set({
                        name: songData.name,
                        driveFileId: songData.driveFileId || songId,
                        isUrl: songData.isUrl || false,
                        url: songData.url || null,
                        position: songData.position || 0,
                        createdAt: songData.createdAt || Date.now()
                    });
                    console.log('âœ… Song saved to Firebase:', songData.name);
                } catch (error) {
                    console.error('âŒ Error saving song:', error);
                    throw error;
                }
            },

            // Delete playlist from Firebase
            async deletePlaylist(userId, playlistId) {
                if (!isFirebaseConfigured) return;
                try {
                    await firebaseDB.ref(`users/${userId}/playlists/${playlistId}`).remove();
                    console.log('âœ… Playlist deleted from Firebase');
                } catch (error) {
                    console.error('âŒ Error deleting playlist:', error);
                    throw error;
                }
            },

            // Delete song from Firebase
            async deleteSong(userId, playlistId, songId) {
                if (!isFirebaseConfigured) return;
                try {
                    await firebaseDB.ref(`users/${userId}/playlists/${playlistId}/songs/${songId}`).remove();
                    console.log('âœ… Song deleted from Firebase');
                } catch (error) {
                    console.error('âŒ Error deleting song:', error);
                    throw error;
                }
            },

            // Listen to all playlists (real-time)
            listenToPlaylists(userId, callback) {
                if (!isFirebaseConfigured) return () => {};
                const ref = firebaseDB.ref(`users/${userId}/playlists`);
                
                ref.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        // Convert Firebase object to array
                        const playlistsArray = Object.keys(data).map(playlistId => ({
                            id: playlistId.replace('pl_', ''), // Remove pl_ prefix for local state
                            name: data[playlistId].name,
                            createdAt: data[playlistId].createdAt,
                            updatedAt: data[playlistId].updatedAt,
                            songs: data[playlistId].songs ? 
                                Object.keys(data[playlistId].songs).map(songId => ({
                                    id: songId,
                                    ...data[playlistId].songs[songId]
                                })).sort((a, b) => a.position - b.position)
                                : []
                        }));
                        callback(playlistsArray);
                    } else {
                        callback([]);
                    }
                });

                // Return unsubscribe function
                return () => ref.off();
            }
        };

        // Debug logging helper
        const debugLog = (message, data) => {
            console.log(`[MusicPlayer] ${message}`, data || '');
        };

        // SVG Icons Component
        const Icons = {
            Sun: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('circle', { cx: '12', cy: '12', r: '5' }),
                React.createElement('line', { x1: '12', y1: '1', x2: '12', y2: '3' }),
                React.createElement('line', { x1: '12', y1: '21', x2: '12', y2: '23' }),
                React.createElement('line', { x1: '4.22', y1: '4.22', x2: '5.64', y2: '5.64' }),
                React.createElement('line', { x1: '18.36', y1: '18.36', x2: '19.78', y2: '19.78' }),
                React.createElement('line', { x1: '1', y1: '12', x2: '3', y2: '12' }),
                React.createElement('line', { x1: '21', y1: '12', x2: '23', y2: '12' }),
                React.createElement('line', { x1: '4.22', y1: '19.78', x2: '5.64', y2: '18.36' }),
                React.createElement('line', { x1: '18.36', y1: '5.64', x2: '19.78', y2: '4.22' })
            ),
            Moon: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('path', { d: 'M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z' })
            ),
            Menu: () => React.createElement('svg', { width: '24', height: '24', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('line', { x1: '3', y1: '6', x2: '21', y2: '6' }),
                React.createElement('line', { x1: '3', y1: '12', x2: '21', y2: '12' }),
                React.createElement('line', { x1: '3', y1: '18', x2: '21', y2: '18' })
            ),
            Home: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('path', { d: 'M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z' }),
                React.createElement('polyline', { points: '9 22 9 12 15 12 15 22' })
            ),
            ArrowLeft: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('line', { x1: '19', y1: '12', x2: '5', y2: '12' }),
                React.createElement('polyline', { points: '12 19 5 12 12 5' })
            ),
            Play: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('polygon', { points: '5 3 19 12 5 21 5 3' })
            ),
            Pause: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('rect', { x: '6', y: '4', width: '4', height: '16' }),
                React.createElement('rect', { x: '14', y: '4', width: '4', height: '16' })
            ),
            SkipBack: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('polygon', { points: '19 20 9 12 19 4 19 20' }),
                React.createElement('rect', { x: '5', y: '4', width: '2', height: '16' })
            ),
            SkipForward: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('polygon', { points: '5 4 15 12 5 20 5 4' }),
                React.createElement('rect', { x: '17', y: '4', width: '2', height: '16' })
            ),
            Repeat: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('polyline', { points: '17 1 21 5 17 9' }),
                React.createElement('path', { d: 'M3 11V9a4 4 0 0 1 4-4h14' }),
                React.createElement('polyline', { points: '7 23 3 19 7 15' }),
                React.createElement('path', { d: 'M21 13v2a4 4 0 0 1-4 4H3' })
            ),
            Volume: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('polygon', { points: '11 5 6 9 2 9 2 15 6 15 11 19 11 5' }),
                React.createElement('path', { d: 'M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07' })
            ),
            Trash: () => React.createElement('svg', { width: '18', height: '18', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('polyline', { points: '3 6 5 6 21 6' }),
                React.createElement('path', { d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2' })
            ),
            Upload: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4' }),
                React.createElement('polyline', { points: '17 8 12 3 7 8' }),
                React.createElement('line', { x1: '12', y1: '3', x2: '12', y2: '15' })
            ),
            Link: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('path', { d: 'M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71' }),
                React.createElement('path', { d: 'M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71' })
            ),
            Music: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('path', { d: 'M9 18V5l12-2v13' }),
                React.createElement('circle', { cx: '6', cy: '18', r: '3' }),
                React.createElement('circle', { cx: '18', cy: '16', r: '3' })
            ),
            MoreVertical: () => React.createElement('svg', { width: '18', height: '18', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('circle', { cx: '12', cy: '5', r: '2' }),
                React.createElement('circle', { cx: '12', cy: '12', r: '2' }),
                React.createElement('circle', { cx: '12', cy: '19', r: '2' })
            ),
            Copy: () => React.createElement('svg', { width: '18', height: '18', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('rect', { x: '9', y: '9', width: '13', height: '13', rx: '2', ry: '2' }),
                React.createElement('path', { d: 'M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1' })
            ),
            GripVertical: () => React.createElement('svg', { width: '16', height: '16', viewBox: '0 0 24 24', fill: 'currentColor' },
                React.createElement('circle', { cx: '9', cy: '5', r: '1' }),
                React.createElement('circle', { cx: '9', cy: '12', r: '1' }),
                React.createElement('circle', { cx: '9', cy: '19', r: '1' }),
                React.createElement('circle', { cx: '15', cy: '5', r: '1' }),
                React.createElement('circle', { cx: '15', cy: '12', r: '1' }),
                React.createElement('circle', { cx: '15', cy: '19', r: '1' })
            ),
            Edit: () => React.createElement('svg', { width: '18', height: '18', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('path', { d: 'M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7' }),
                React.createElement('path', { d: 'M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z' })
            ),
            Bug: () => React.createElement('svg', { width: '20', height: '20', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2' },
                React.createElement('rect', { x: '8', y: '6', width: '8', height: '14', rx: '4' }),
                React.createElement('path', { d: 'M8 6h8M12 2v4M8 10h8M8 14h8' })
            )
        };

        // IndexedDB with better error handling
        const initDB = () => {
            return new Promise((resolve, reject) => {
                debugLog('Initializing IndexedDB...');
                const req = indexedDB.open('MusicDB', 3);
                
                req.onerror = () => {
                    debugLog('IndexedDB error:', req.error);
                    reject(req.error);
                };
                
                req.onsuccess = () => {
                    debugLog('IndexedDB opened successfully');
                    resolve(req.result);
                };
                
                req.onupgradeneeded = (e) => {
                    debugLog('IndexedDB upgrade needed');
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('playlists')) {
                        db.createObjectStore('playlists', { keyPath: 'id' });
                        debugLog('Created playlists store');
                    }
                    if (!db.objectStoreNames.contains('songs')) {
                        db.createObjectStore('songs', { keyPath: 'id' });
                        debugLog('Created songs store');
                    }
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                        debugLog('Created settings store');
                    }
                };
            });
        };

        const DB = {
            async save(store, data) {
                try {
                    debugLog(`Saving to ${store}:`, data.id || data.key);
                    const db = await initDB();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(store, 'readwrite');
                        const req = tx.objectStore(store).put(data);
                        
                        req.onsuccess = () => {
                            debugLog(`Saved to ${store} successfully`);
                            resolve(req.result);
                        };
                        
                        req.onerror = () => {
                            debugLog(`Error saving to ${store}:`, req.error);
                            reject(req.error);
                        };
                        
                        tx.oncomplete = () => {
                            debugLog(`Transaction complete for ${store}`);
                        };
                    });
                } catch (e) {
                    debugLog('DB save error:', e);
                    throw e;
                }
            },
            
            async get(store, key) {
                try {
                    debugLog(`Getting from ${store}:`, key);
                    const db = await initDB();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(store, 'readonly');
                        const req = tx.objectStore(store).get(key);
                        
                        req.onsuccess = () => {
                            debugLog(`Got from ${store}:`, req.result ? 'Found' : 'Not found');
                            resolve(req.result);
                        };
                        
                        req.onerror = () => {
                            debugLog(`Error getting from ${store}:`, req.error);
                            reject(req.error);
                        };
                    });
                } catch (e) {
                    debugLog('DB get error:', e);
                    return null;
                }
            },
            
            async getAll(store) {
                try {
                    debugLog(`Getting all from ${store}`);
                    const db = await initDB();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(store, 'readonly');
                        const req = tx.objectStore(store).getAll();
                        
                        req.onsuccess = () => {
                            const result = req.result || [];
                            debugLog(`Got all from ${store}: ${result.length} items`);
                            resolve(result);
                        };
                        
                        req.onerror = () => {
                            debugLog(`Error getting all from ${store}:`, req.error);
                            reject(req.error);
                        };
                    });
                } catch (e) {
                    debugLog('DB getAll error:', e);
                    return [];
                }
            },
            
            async delete(store, key) {
                try {
                    debugLog(`Deleting from ${store}:`, key);
                    const db = await initDB();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(store, 'readwrite');
                        const req = tx.objectStore(store).delete(key);
                        
                        req.onsuccess = () => {
                            debugLog(`Deleted from ${store} successfully`);
                            resolve();
                        };
                        
                        req.onerror = () => {
                            debugLog(`Error deleting from ${store}:`, req.error);
                            reject(req.error);
                        };
                    });
                } catch (e) {
                    debugLog('DB delete error:', e);
                }
            }
        };

        function MusicPlayer() {
            const [playlists, setPlaylists] = useState([]);
            const [activePlaylist, setActivePlaylist] = useState(null);
            const [view, setView] = useState('home');
            const [currentSong, setCurrentSong] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [repeat, setRepeat] = useState(false);
            const [progress, setProgress] = useState(0);
            const [volume, setVolume] = useState(80);
            const [darkMode, setDarkMode] = useState(true);
            const [language, setLanguage] = useState('en'); // 'en' or 'zh'
            const [searchQuery, setSearchQuery] = useState('');
            const [sidebarOpen, setSidebarOpen] = useState(false);
            const [showModal, setShowModal] = useState(null);
            const [modalInput, setModalInput] = useState('');
            const [loading, setLoading] = useState(true);
            const [showWelcome, setShowWelcome] = useState(false); // Welcome page state
            const [isDragging, setIsDragging] = useState(false); // Drag-and-drop state
            const [isOnline, setIsOnline] = useState(navigator.onLine);
            const [contextMenu, setContextMenu] = useState(null);
            const [draggedPlaylist, setDraggedPlaylist] = useState(null);
            const [draggedSong, setDraggedSong] = useState(null);
            const [recentPlaylistId, setRecentPlaylistId] = useState(null);
            const [showDebug, setShowDebug] = useState(false);
            const [debugInfo, setDebugInfo] = useState({});
            const [firebaseError, setFirebaseError] = useState(null); // Track Firebase errors
            const [editingPlaylist, setEditingPlaylist] = useState(null);
            const [editingPlaylistName, setEditingPlaylistName] = useState('');
            const [editingSong, setEditingSong] = useState(null);
            const [editingSongName, setEditingSongName] = useState('');
            
            // Firebase state
            const [firebaseUserId, setFirebaseUserId] = useState(null);
            const [googleUserId, setGoogleUserId] = useState(null); // Track Google ID
            const [firebaseReady, setFirebaseReady] = useState(false);
            
            // Sync state variables
            const [isSignedIn, setIsSignedIn] = useState(false);
            const [userInfo, setUserInfo] = useState(null);
            const [accessToken, setAccessToken] = useState(null);
            const [syncing, setSyncing] = useState(false);
            const [syncStatus, setSyncStatus] = useState('');
            const [quotaCalls, setQuotaCalls] = useState(0);
            const [cancelSync, setCancelSync] = useState(false);
            
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);
            const saveTimeoutRef = useRef(null);
            const longPressTimer = useRef(null);

            const bg = darkMode ? 'bg-dark' : 'bg-light';
            const sidebar = darkMode ? 'sidebar-dark' : 'sidebar-light';
            const card = darkMode ? 'card-dark' : 'card-light';
            const txtMuted = darkMode ? 'text-muted-dark' : 'text-muted-light';
            const modalClass = darkMode ? 'modal-dark' : 'modal-light';

            // Update debug info
            useEffect(() => {
                setDebugInfo({
                    playlistCount: playlists.length,
                    activePlaylist: activePlaylist ? 'Set' : 'None',
                    loading: loading,
                    isOnline: isOnline,
                    currentSong: currentSong ? currentSong.name : 'None',
                    lastUpdate: new Date().toLocaleTimeString()
                });
            }, [playlists, activePlaylist, loading, isOnline, currentSong]);

            // Translations (Taiwanese Traditional Chinese)
            const t = {
                en: {
                    // Welcome page
                    welcomeTitle: 'Music Player',
                    welcomeSubtitle: 'Your music, everywhere',
                    signInGoogle: 'Sign in with Google',
                    signInDesc: 'Sync across all devices',
                    continueGuest: 'Continue as Guest',
                    continueDesc: 'Local storage only',
                    guestWarning: "Guest mode won't sync - data stays local only",
                    guestModeTitle: "Guest Mode",
                    guestModeSubtitle: "Your music will:",
                    guestModeBullet1: "Stay on this device only",
                    guestModeBullet2: "NOT sync to Google Drive",
                    guestModeBullet3: "NOT transfer if you sign in later",
                    guestModeTip: "ðŸ’¡ Tip: Sign in with Google Drive to keep your files and sync across all devices.",
                    
                    // Sidebar
                    home: 'Home',
                    createPlaylist: 'Create Playlist',
                    createNewPlaylist: '+ Create New Playlist',
                    backupShare: 'Backup & Share',
                    search: 'Search...',
                    yourLibrary: 'Your Library',
                    guestMode: 'Guest Mode',
                    signIn: 'Sign in with Google',
                    signOut: 'Sign Out',
                    
                    // Playlist
                    uploadFiles: 'Upload Files',
                    addUrl: 'Add URL',
                    tracks: 'tracks',
                    noTracksYet: 'No tracks yet',
                    uploadOrAdd: 'Upload audio files or add streaming URLs',
                    
                    // Modals
                    createPlaylistTitle: 'Create Playlist',
                    playlistName: 'Playlist name',
                    cancel: 'Cancel',
                    create: 'Create',
                    addStreamingUrl: 'Add Streaming URL',
                    add: 'Add',
                    backupShareTitle: 'Backup & Share',
                    exportPlaylists: 'Export Playlists',
                    importPlaylists: 'Import Playlists',
                    close: 'Close',
                    deletePlaylist: 'Delete Playlist?',
                    deletePlaylistMsg: 'This will delete all songs in this playlist. This action cannot be undone.',
                    deleteTrack: 'Delete Track?',
                    deleteTrackMsg: 'This action cannot be undone.',
                    delete: 'Delete Playlist',
                    deleteButton: 'Delete',
                    
                    // Player
                    repeat: 'Repeat',
                    previous: 'Previous',
                    play: 'Play',
                    pause: 'Pause',
                    next: 'Next',
                    
                    // Messages
                    signedOut: 'âœ… Signed out successfully!',
                    offlineMode: 'Offline Mode - Only local songs available',
                    loadingLibrary: 'Loading your library...',
                    pleaseWait: 'Please wait',
                    
                    // Drag and drop
                    dropFiles: 'Drop files here to upload',
                    
                    // Status
                    apiCalls: 'API calls today',
                    streaming: 'Streaming',
                    local: 'Local',
                    
                    // Context menu
                    duplicate: 'Duplicate',
                    delete: 'Delete',
                    
                    // Search
                    searchPlaceholder: 'Search playlists or songs...',
                    
                    // Sign in description
                    signInDescription: 'Sign in once to activate both Google Drive storage and real-time sync across all devices'
                },
                zh: {
                    // Welcome page  
                    welcomeTitle: 'éŸ³æ¨‚æ’­æ”¾å™¨',
                    welcomeSubtitle: 'æ‚¨çš„éŸ³æ¨‚ï¼Œç„¡è™•ä¸åœ¨',
                    signInGoogle: 'ä½¿ç”¨ Google ç™»å…¥',
                    signInDesc: 'è·¨è£ç½®åŒæ­¥',
                    continueGuest: 'ä»¥è¨ªå®¢èº«ä»½ç¹¼çºŒ',
                    continueDesc: 'åƒ…æœ¬æ©Ÿå„²å­˜',
                    guestWarning: 'è¨ªå®¢æ¨¡å¼ä¸æœƒåŒæ­¥ - è³‡æ–™åƒ…å„²å­˜æ–¼æœ¬æ©Ÿ',
                    guestModeTitle: "è¨ªå®¢æ¨¡å¼",
                    guestModeSubtitle: "æ‚¨çš„éŸ³æ¨‚å°‡ï¼š",
                    guestModeBullet1: "åƒ…ä¿å­˜åœ¨æ­¤è£ç½®ä¸Š",
                    guestModeBullet2: "ä¸æœƒåŒæ­¥è‡³ Google é›²ç«¯ç¡¬ç¢Ÿ",
                    guestModeBullet3: "æ—¥å¾Œç™»å…¥æ™‚ä¸æœƒè½‰ç§»",
                    guestModeTip: "ðŸ’¡ æç¤ºï¼šä½¿ç”¨ Google é›²ç«¯ç¡¬ç¢Ÿç™»å…¥ä»¥ä¿ç•™æª”æ¡ˆä¸¦è·¨è£ç½®åŒæ­¥ã€‚",
                    
                    // Sidebar
                    home: 'é¦–é ',
                    createPlaylist: 'å»ºç«‹æ’­æ”¾æ¸…å–®',
                    createNewPlaylist: '+ å»ºç«‹æ–°æ’­æ”¾æ¸…å–®',
                    backupShare: 'å‚™ä»½èˆ‡åˆ†äº«',
                    search: 'æœå°‹...',
                    yourLibrary: 'æ‚¨çš„è³‡æ–™åº«',
                    guestMode: 'è¨ªå®¢æ¨¡å¼',
                    signIn: 'ä½¿ç”¨ Google ç™»å…¥',
                    signOut: 'ç™»å‡º',
                    
                    // Playlist
                    uploadFiles: 'ä¸Šå‚³æª”æ¡ˆ',
                    addUrl: 'æ–°å¢žç¶²å€',
                    tracks: 'é¦–æ›²ç›®',
                    noTracksYet: 'å°šç„¡æ›²ç›®',
                    uploadOrAdd: 'ä¸Šå‚³éŸ³è¨Šæª”æ¡ˆæˆ–æ–°å¢žä¸²æµç¶²å€',
                    
                    // Modals
                    createPlaylistTitle: 'å»ºç«‹æ’­æ”¾æ¸…å–®',
                    playlistName: 'æ’­æ”¾æ¸…å–®åç¨±',
                    cancel: 'å–æ¶ˆ',
                    create: 'å»ºç«‹',
                    addStreamingUrl: 'æ–°å¢žä¸²æµç¶²å€',
                    add: 'æ–°å¢ž',
                    backupShareTitle: 'å‚™ä»½èˆ‡åˆ†äº«',
                    exportPlaylists: 'åŒ¯å‡ºæ’­æ”¾æ¸…å–®',
                    importPlaylists: 'åŒ¯å…¥æ’­æ”¾æ¸…å–®',
                    close: 'é—œé–‰',
                    deletePlaylist: 'åˆªé™¤æ’­æ”¾æ¸…å–®ï¼Ÿ',
                    deletePlaylistMsg: 'é€™å°‡åˆªé™¤æ­¤æ’­æ”¾æ¸…å–®ä¸­çš„æ‰€æœ‰æ­Œæ›²ã€‚æ­¤æ“ä½œç„¡æ³•å¾©åŽŸã€‚',
                    deleteTrack: 'åˆªé™¤æ›²ç›®ï¼Ÿ',
                    deleteTrackMsg: 'æ­¤æ“ä½œç„¡æ³•å¾©åŽŸã€‚',
                    delete: 'åˆªé™¤æ’­æ”¾æ¸…å–®',
                    deleteButton: 'åˆªé™¤',
                    
                    // Player
                    repeat: 'é‡è¤‡æ’­æ”¾',
                    previous: 'ä¸Šä¸€é¦–',
                    play: 'æ’­æ”¾',
                    pause: 'æš«åœ',
                    next: 'ä¸‹ä¸€é¦–',
                    
                    // Messages
                    signedOut: 'âœ… å·²æˆåŠŸç™»å‡ºï¼',
                    offlineMode: 'é›¢ç·šæ¨¡å¼ - åƒ…å¯ä½¿ç”¨æœ¬æ©Ÿæ­Œæ›²',
                    loadingLibrary: 'æ­£åœ¨è¼‰å…¥æ‚¨çš„è³‡æ–™åº«...',
                    pleaseWait: 'è«‹ç¨å€™',
                    
                    // Drag and drop
                    dropFiles: 'å°‡æª”æ¡ˆæ‹–æ”¾è‡³æ­¤è™•ä¸Šå‚³',
                    
                    // Status
                    apiCalls: 'ä»Šæ—¥ API å‘¼å«æ¬¡æ•¸',
                    streaming: 'ä¸²æµ',
                    local: 'æœ¬æ©Ÿ',
                    
                    // Context menu
                    duplicate: 'è¤‡è£½',
                    delete: 'åˆªé™¤',
                    
                    // Search
                    searchPlaceholder: 'æœå°‹æ’­æ”¾æ¸…å–®æˆ–æ­Œæ›²...',
                    
                    // Sign in description
                    signInDescription: 'ç™»å…¥ä¸€æ¬¡å³å¯å•Ÿç”¨ Google é›²ç«¯ç¡¬ç¢Ÿå„²å­˜ç©ºé–“ï¼Œä¸¦åœ¨æ‰€æœ‰è£ç½®é–“å³æ™‚åŒæ­¥'
                }
            }[language];

            // Online/Offline detection
            useEffect(() => {
                const handleOnline = () => {
                    debugLog('Network: Online');
                    setIsOnline(true);
                };
                const handleOffline = () => {
                    debugLog('Network: Offline');
                    setIsOnline(false);
                };
                
                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);
                
                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                };
            }, []);

            // Close context menu on click outside
            useEffect(() => {
                const handleClick = () => setContextMenu(null);
                document.addEventListener('click', handleClick);
                return () => document.removeEventListener('click', handleClick);
            }, []);

            // Drag-and-drop file upload
            useEffect(() => {
                let dragCounter = 0;
                
                const handleDragEnter = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                        dragCounter++;
                        if (dragCounter === 1) {
                            setIsDragging(true);
                        }
                    }
                };

                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };

                const handleDragLeave = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    dragCounter--;
                    if (dragCounter === 0) {
                        setIsDragging(false);
                    }
                };

                const handleDrop = async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragCounter = 0;
                    setIsDragging(false);

                    if (!activePlaylist) {
                        alert(language === 'zh' ? 'è«‹å…ˆé¸æ“‡æ’­æ”¾æ¸…å–®ï¼' : 'Please select a playlist first');
                        return;
                    }

                    const files = Array.from(e.dataTransfer.files).filter(f => 
                        f.type.startsWith('audio/') || 
                        f.name.match(/\.(mp3|m4a|wav|aac|flac|ogg|mp4)$/i)
                    );

                    if (files.length === 0) {
                        alert(language === 'zh' ? 'æœªæª¢æ¸¬åˆ°éŸ³è¨Šæª”æ¡ˆ' : 'No audio files detected');
                        return;
                    }

                    // Use the same upload logic as file input
                    const fakeEvent = { target: { files } };
                    await handleFileUpload(fakeEvent);
                };

                document.addEventListener('dragenter', handleDragEnter);
                document.addEventListener('dragover', handleDragOver);
                document.addEventListener('dragleave', handleDragLeave);
                document.addEventListener('drop', handleDrop);

                return () => {
                    document.removeEventListener('dragenter', handleDragEnter);
                    document.removeEventListener('dragover', handleDragOver);
                    document.removeEventListener('dragleave', handleDragLeave);
                    document.removeEventListener('drop', handleDrop);
                };
            }, [activePlaylist, language]);

            // FIXED: Load data with proper async/await
            useEffect(() => { 
                loadData(); 
            }, []);

            // Firebase Real-Time Listener
            useEffect(() => {
                if (!firebaseUserId || !isFirebaseConfigured) return;
                
                console.log('ðŸ”¥ Starting Firebase real-time listener for UID:', firebaseUserId);
                
                const unsubscribe = FirebaseDB.listenToPlaylists(firebaseUserId, (firebasePlaylists) => {
                    console.log('ðŸ“¡ Firebase real-time update received:', firebasePlaylists.length, 'playlists');
                    console.log('ðŸ“¡ Firebase data:', firebasePlaylists);
                    
                    // Update playlists from Firebase
                    setPlaylists(prevPlaylists => {
                        // Only update if data actually changed
                        if (JSON.stringify(prevPlaylists) === JSON.stringify(firebasePlaylists)) {
                            console.log('ðŸ“¡ No changes detected, skipping update');
                            return prevPlaylists;
                        }
                        console.log('ðŸ“¡ Data changed, updating UI');
                        return firebasePlaylists;
                    });
                    
                    // If no active playlist but playlists exist, set first one
                    if (!activePlaylist && firebasePlaylists.length > 0) {
                        setActivePlaylist(firebasePlaylists[0].id);
                    }
                    
                    // If active playlist was deleted, switch to another
                    if (activePlaylist && !firebasePlaylists.find(p => p.id === activePlaylist)) {
                        setActivePlaylist(firebasePlaylists.length > 0 ? firebasePlaylists[0].id : null);
                    }
                });
                
                return () => {
                    console.log('ðŸ”¥ Stopping Firebase listener');
                    unsubscribe();
                };
            }, [firebaseUserId]);

            const loadData = async () => {
                try {
                    debugLog('=== STARTING DATA LOAD ===');
                    setLoading(true);
                    
                    // Check if first-time user
                    const hasSeenWelcome = localStorage.getItem('hasSeenWelcome');
                    
                    // Wait for all data to load
                    const [lists, mode, vol, recent, auth, quotaData] = await Promise.all([
                        DB.getAll('playlists'),
                        DB.get('settings', 'darkMode'),
                        DB.get('settings', 'volume'),
                        DB.get('settings', 'recentPlaylist'),
                        DB.get('settings', 'googleAuth'),
                        DB.get('settings', 'quotaTracking')
                    ]);
                    
                    debugLog('Loaded playlists:', lists.length);
                    debugLog('Loaded darkMode:', mode?.value);
                    debugLog('Loaded volume:', vol?.value);
                    debugLog('Loaded recent:', recent?.value);
                    debugLog('Loaded auth:', auth ? 'Yes' : 'No');
                    
                    // Show welcome page if first time (no flag AND no playlists)
                    if (!hasSeenWelcome && (!lists || lists.length === 0)) {
                        debugLog('First time user - showing welcome page');
                        setShowWelcome(true);
                        setLoading(false);
                        return; // Don't continue loading
                    }
                    
                    // Set all state AFTER data is loaded
                    if (lists && lists.length > 0) {
                        setPlaylists(lists);
                        const recentId = recent?.value || lists[0].id;
                        setRecentPlaylistId(recentId);
                        setActivePlaylist(recentId);
                        debugLog('Set active playlist:', recentId);
                    } else {
                        debugLog('No playlists found');
                        setPlaylists([]);
                        setActivePlaylist(null);
                        setRecentPlaylistId(null);
                    }
                    
                    if (mode) setDarkMode(mode.value);
                    
                    // Restore language preference
                    const savedLang = localStorage.getItem('language');
                    if (savedLang) setLanguage(savedLang);
                    if (vol) setVolume(vol.value);
                    
                    // Restore auth state if token is still valid
                    if (auth?.value) {
                        const { userInfo, accessToken, expiresAt } = auth.value;
                        if (expiresAt && Date.now() < expiresAt) {
                            setIsSignedIn(true);
                            setUserInfo(userInfo);
                            setAccessToken(accessToken);
                            debugLog('Auth restored:', userInfo.name);
                            
                            // CRITICAL: Restore Firebase UID for this Google account
                            if (userInfo.id) {
                                const storedMapping = await DB.get('settings', 'firebaseUidMapping');
                                const firebaseUid = storedMapping?.value?.[userInfo.id];
                                if (firebaseUid) {
                                    setFirebaseUserId(firebaseUid);
                                    console.log('ðŸ”¥ Restored Firebase UID from storage:', firebaseUid);
                                    setGoogleUserId(userInfo.id);
                                } else {
                                    console.log('âš ï¸ No Firebase UID mapping found for this Google account');
                                }
                            }
                        } else {
                            debugLog('Auth token expired');
                            await DB.delete('settings', 'googleAuth');
                        }
                    }
                    
                    // Restore quota count (resets daily)
                    if (quotaData?.value) {
                        const today = new Date().toDateString();
                        const { date, count } = quotaData.value;
                        
                        if (date === today) {
                            setQuotaCalls(count);
                            debugLog('Quota restored:', count);
                        } else {
                            // New day - reset to 0
                            setQuotaCalls(0);
                            await DB.save('settings', {
                                key: 'quotaTracking',
                                value: { date: today, count: 0 }
                            });
                            debugLog('Quota reset for new day');
                        }
                    }
                    
                    debugLog('=== DATA LOAD COMPLETE ===');
                } catch (e) {
                    debugLog('Load error:', e);
                    alert('Error loading data: ' + e.message);
                } finally {
                    // Small delay to ensure everything is rendered
                    setTimeout(() => {
                        setLoading(false);
                        debugLog('Loading state set to false');
                    }, 300);
                }
            };

            // FIXED: Debounced save for playlists
            useEffect(() => {
                if (loading) return;
                
                debugLog('Playlist changed, scheduling save...');
                
                // Clear previous timeout
                if (saveTimeoutRef.current) {
                    clearTimeout(saveTimeoutRef.current);
                }
                
                // Save after 500ms of no changes
                saveTimeoutRef.current = setTimeout(async () => {
                    debugLog('Saving all playlists...');
                    for (const p of playlists) {
                        await DB.save('playlists', p);
                    }
                    debugLog('All playlists saved');
                }, 500);
                
                return () => {
                    if (saveTimeoutRef.current) {
                        clearTimeout(saveTimeoutRef.current);
                    }
                };
            }, [playlists, loading]);

            useEffect(() => {
                if (!loading) DB.save('settings', { key: 'darkMode', value: darkMode });
            }, [darkMode, loading]);

            useEffect(() => {
                localStorage.setItem('language', language);
            }, [language]);

            useEffect(() => {
                if (!loading) DB.save('settings', { key: 'volume', value: volume });
            }, [volume, loading]);

            useEffect(() => {
                if (!loading && activePlaylist) {
                    DB.save('settings', { key: 'recentPlaylist', value: activePlaylist });
                    setRecentPlaylistId(activePlaylist);
                }
            }, [activePlaylist, loading]);

            useEffect(() => {
                if (audioRef.current && currentSong) {
                    audioRef.current.src = currentSong.url;
                    audioRef.current.load();
                    if (isPlaying) audioRef.current.play().catch(() => setIsPlaying(false));
                }
            }, [currentSong]);

            useEffect(() => {
                if (audioRef.current && currentSong) {
                    if (isPlaying) audioRef.current.play().catch(() => setIsPlaying(false));
                    else audioRef.current.pause();
                }
            }, [isPlaying]);

            useEffect(() => {
                if (audioRef.current) audioRef.current.volume = volume / 100;
            }, [volume]);

            // Sync function - SYNCS PLAYLISTS + SONGS (FIXED ORDER: Download first!)
            const handleSync = async () => {
                if (!accessToken || !isSignedIn) {
                    alert('Please sign in first!');
                    return;
                }
                
                try {
                    setSyncing(true);
                    setCancelSync(false);
                    setSyncStatus('Initializing...');
                    
                    if (cancelSync) throw new Error('Sync cancelled by user');
                    
                    const folderId = await DriveAPI.ensureFolder(accessToken);
                    setSyncStatus('Listing Drive files...');
                    const driveFiles = await DriveAPI.listFiles(accessToken, folderId);
                    
                    if (cancelSync) throw new Error('Sync cancelled by user');
                    
                    // STEP 1: Download and merge playlists from Drive FIRST
                    setSyncStatus('Downloading playlists from Drive...');
                    const playlistsFile = driveFiles.files?.find(f => f.name === 'playlists.json');
                    
                    // Load deleted items tracking from Drive
                    let deletedData = await DB.get('settings', 'deletedItems') || { key: 'deletedItems', value: { playlists: [], songs: {} } };
                    
                    // Download deleted.json from Drive and merge
                    const deletedFile = driveFiles.files?.find(f => f.name === 'deleted.json');
                    console.log('ðŸ” [SYNC DEBUG] deleted.json exists in Drive?', !!deletedFile);
                    
                    if (deletedFile) {
                        try {
                            const deletedBlob = await DriveAPI.downloadFile(accessToken, deletedFile.id);
                            const deletedText = await deletedBlob.text();
                            const driveDeleted = JSON.parse(deletedText);
                            
                            console.log('ðŸ” [SYNC DEBUG] Downloaded deleted.json:', driveDeleted);
                            
                            // Merge deletion lists (union of both)
                            const mergedDeletedPlaylists = [...new Set([
                                ...(deletedData.value?.playlists || []),
                                ...(driveDeleted.playlists || [])
                            ])];
                            
                            console.log('ðŸ” [SYNC DEBUG] Local deletions:', deletedData.value?.playlists);
                            console.log('ðŸ” [SYNC DEBUG] Drive deletions:', driveDeleted.playlists);
                            console.log('ðŸ” [SYNC DEBUG] Merged deletions:', mergedDeletedPlaylists);
                            
                            const mergedDeletedSongs = { ...(deletedData.value?.songs || {}), ...(driveDeleted.songs || {}) };
                            // Merge song arrays per playlist
                            Object.keys(driveDeleted.songs || {}).forEach(playlistName => {
                                if (mergedDeletedSongs[playlistName]) {
                                    mergedDeletedSongs[playlistName] = [...new Set([
                                        ...mergedDeletedSongs[playlistName],
                                        ...driveDeleted.songs[playlistName]
                                    ])];
                                } else {
                                    mergedDeletedSongs[playlistName] = driveDeleted.songs[playlistName];
                                }
                            });
                            
                            deletedData = {
                                key: 'deletedItems',
                                value: {
                                    playlists: mergedDeletedPlaylists,
                                    songs: mergedDeletedSongs
                                }
                            };
                            await DB.save('settings', deletedData);
                        } catch (e) {
                            console.error('Error loading deleted.json:', e);
                        }
                    }
                    
                    const deletedPlaylists = deletedData.value?.playlists || [];
                    const deletedSongs = deletedData.value?.songs || {};
                    
                    // CRITICAL: Filter local playlists FIRST to remove deleted ones
                    console.log('ðŸ” [SYNC DEBUG] Local playlists BEFORE filter:', playlists.map(p => p.name));
                    console.log('ðŸ” [SYNC DEBUG] Deleted playlists list:', deletedPlaylists);
                    console.log('ðŸ” [SYNC DEBUG] Deleted songs:', deletedSongs);
                    
                    // SAFETY CHECK: If deletions would remove ALL playlists, something is wrong - clear the deletion list
                    let mergedPlaylists;
                    if (playlists.length > 0 && deletedPlaylists.length >= playlists.length) {
                        console.warn('âš ï¸ WARNING: Deletion list would remove ALL playlists! Clearing deletion list to prevent data loss.');
                        mergedPlaylists = [...playlists];
                        // Clear the bad deletion data
                        deletedData.value = { playlists: [], songs: {} };
                        await DB.save('settings', deletedData);
                    } else {
                        mergedPlaylists = playlists.filter(p => !deletedPlaylists.includes(p.name));
                    }
                    
                    console.log('ðŸ” [SYNC DEBUG] Playlists AFTER filter:', mergedPlaylists.map(p => p.name));
                    
                    // Also filter deleted songs from remaining local playlists
                    mergedPlaylists.forEach(playlist => {
                        const playlistDeletedSongs = deletedSongs[playlist.name] || [];
                        const beforeCount = playlist.songs.length;
                        playlist.songs = playlist.songs.filter(s => !playlistDeletedSongs.includes(s.id));
                        const afterCount = playlist.songs.length;
                        if (beforeCount !== afterCount) {
                            console.log(`ðŸ” [SYNC DEBUG] Filtered ${beforeCount - afterCount} songs from "${playlist.name}"`);
                        }
                    });
                    
                    // Save filtered playlists to DB immediately
                    for (const playlist of mergedPlaylists) {
                        await DB.save('playlists', playlist);
                    }
                    
                    // Delete playlists that were filtered out from DB
                    for (const playlist of playlists) {
                        if (deletedPlaylists.includes(playlist.name)) {
                            await DB.delete('playlists', playlist.id);
                            // Also delete songs
                            for (const song of playlist.songs) {
                                if (!song.isUrl) {
                                    await DB.delete('songs', song.id);
                                }
                            }
                        }
                    }
                    
                    
                    let downloadCount = 0;
                    
                    if (playlistsFile) {
                        const metaBlob = await DriveAPI.downloadFile(accessToken, playlistsFile.id);
                        const metaText = await metaBlob.text();
                        let drivePlaylists = [];
                        
                        try {
                            const parsed = JSON.parse(metaText);
                            drivePlaylists = Array.isArray(parsed) ? parsed : [];
                        } catch (e) {
                            console.error('Error parsing playlists.json:', e);
                            drivePlaylists = [];
                        }
                        
                        // Filter out deleted playlists from Drive
                        drivePlaylists = drivePlaylists.filter(p => !deletedPlaylists.includes(p.name));
                        
                        // CRITICAL: Also filter deleted songs from Drive playlists BEFORE merging!
                        drivePlaylists.forEach(drivePlaylist => {
                            const playlistDeletedSongs = deletedSongs[drivePlaylist.name] || [];
                            const beforeCount = drivePlaylist.songs.length;
                            drivePlaylist.songs = drivePlaylist.songs.filter(s => !playlistDeletedSongs.includes(s.id));
                            const afterCount = drivePlaylist.songs.length;
                            if (beforeCount !== afterCount) {
                                console.log(`ðŸ” [SYNC DEBUG] Filtered ${beforeCount - afterCount} deleted songs from Drive's "${drivePlaylist.name}" BEFORE merge`);
                            }
                        });
                        
                        console.log('ðŸ” [SYNC DEBUG] Drive playlists AFTER filtering deletions:', drivePlaylists.map(p => `${p.name} (${p.songs.length} songs)`));
                        
                        // Merge Drive playlists with local
                        for (const drivePlaylist of drivePlaylists) {
                            if (cancelSync) throw new Error('Sync cancelled by user');
                            
                            let localPlaylist = mergedPlaylists.find(p => p.name === drivePlaylist.name);
                            
                            if (!localPlaylist) {
                                // New playlist from Drive - create it
                                localPlaylist = {
                                    id: Date.now() + Math.random(),
                                    name: drivePlaylist.name,
                                    songs: []
                                };
                                mergedPlaylists.push(localPlaylist);
                            }
                            
                            // Download songs for this playlist
                            const playlistDeletedSongs = deletedSongs[drivePlaylist.name] || [];
                            
                            for (const driveSong of drivePlaylist.songs) {
                                // Skip deleted songs (from deletion tracking)
                                if (playlistDeletedSongs.includes(driveSong.id)) {
                                    console.log(`â­ï¸ Skipping deleted song from tracking: ${driveSong.name}`);
                                    continue;
                                }
                                
                                if (driveSong.isUrl) {
                                    if (!localPlaylist.songs.find(s => s.id === driveSong.id)) {
                                        localPlaylist.songs.push(driveSong);
                                    }
                                } else {
                                    const hasLocally = await DB.get('songs', driveSong.id);
                                    
                                    if (!hasLocally) {
                                        const fileName = createFileName(driveSong.name, driveSong.id);
                                        const songFile = driveFiles.files?.find(f => f.name === fileName);
                                        
                                        if (songFile) {
                                            setSyncStatus(`Downloading: ${driveSong.name}...`);
                                            const blob = await DriveAPI.downloadFile(accessToken, songFile.id);
                                            await DB.save('songs', { id: driveSong.id, blob });
                                            downloadCount++;
                                        }
                                    }
                                    
                                    if (!localPlaylist.songs.find(s => s.id === driveSong.id)) {
                                        localPlaylist.songs.push({
                                            id: driveSong.id,
                                            name: driveSong.name,
                                            isUrl: false
                                        });
                                    }
                                }
                            }
                            
                            await DB.save('playlists', localPlaylist);
                        }
                    }
                    
                    // Don't clear deletions yet - upload to Drive first!
                    
                    // CLEANUP: Delete orphaned files from Drive AFTER merge (so we know what's valid)
                    setSyncStatus('Cleaning up old files...');
                    
                    // Get list of ALL song IDs that should exist (from merged playlists)
                    const validSongIds = new Set();
                    for (const playlist of mergedPlaylists) {
                        for (const song of playlist.songs) {
                            if (!song.isUrl) {
                                validSongIds.add(song.id);
                            }
                        }
                    }
                    
                    console.log('ðŸ” [SYNC DEBUG] Valid song IDs AFTER merge (should keep):', Array.from(validSongIds));
                    
                    // Delete orphaned audio files from Drive
                    let deletedFilesCount = 0;
                    for (const file of driveFiles.files || []) {
                        // Skip metadata files
                        if (file.name === 'playlists.json' || file.name === 'deleted.json' || file.name === 'quota.json') {
                            continue;
                        }
                        
                        // Extract song ID from filename
                        const match = file.name.match(/-([a-z0-9]{4})\.(mp3|m4a|wav|ogg)$/i);
                        const songId = match ? match[1] : null;
                        
                        if (songId && !validSongIds.has(songId)) {
                            console.log(`ðŸ—‘ï¸ Deleting orphaned file from Drive: ${file.name}`);
                            try {
                                await fetch(
                                    `https://www.googleapis.com/drive/v3/files/${file.id}`,
                                    {
                                        method: 'DELETE',
                                        headers: { 'Authorization': `Bearer ${accessToken}` }
                                    }
                                );
                                setQuotaCalls(prev => prev + 1);
                                deletedFilesCount++;
                            } catch (e) {
                                console.error('Error deleting file:', file.name, e);
                            }
                        }
                    }
                    
                    console.log(`ðŸ” [SYNC DEBUG] Deleted ${deletedFilesCount} orphaned files from Drive`);
                    
                    // STEP 2: Now upload merged playlists metadata to Drive
                    setSyncStatus('Uploading playlist metadata...');
                    const playlistsMetadata = mergedPlaylists.map(p => ({
                        id: p.id,
                        name: p.name,
                        songs: p.songs.map(s => ({
                            id: s.id,
                            name: s.name,
                            isUrl: s.isUrl,
                            url: s.url
                        }))
                    }));
                    
                    console.log('ðŸ” [SYNC DEBUG] About to upload playlists.json:', playlistsMetadata.map(p => p.name));
                    console.log('ðŸ” [SYNC DEBUG] Full metadata:', JSON.stringify(playlistsMetadata, null, 2));
                    
                    const metadataBlob = new Blob([JSON.stringify(playlistsMetadata, null, 2)], { type: 'application/json' });
                    
                    const existingMeta = driveFiles.files?.find(f => f.name === 'playlists.json');
                    if (existingMeta) {
                        await fetch(
                            `https://www.googleapis.com/drive/v3/files/${existingMeta.id}`,
                            {
                                method: 'DELETE',
                                headers: { 'Authorization': `Bearer ${accessToken}` }
                            }
                        );
                        setQuotaCalls(prev => prev + 1);
                    }
                    
                    await DriveAPI.uploadFile(accessToken, folderId, 'playlists.json', metadataBlob);
                    
                    // Upload deletion tracking to Drive
                    setSyncStatus('Syncing deletions...');
                    const deletedBlob = new Blob([JSON.stringify(deletedData.value, null, 2)], { type: 'application/json' });
                    const existingDeleted = driveFiles.files?.find(f => f.name === 'deleted.json');
                    if (existingDeleted) {
                        await fetch(
                            `https://www.googleapis.com/drive/v3/files/${existingDeleted.id}`,
                            {
                                method: 'DELETE',
                                headers: { 'Authorization': `Bearer ${accessToken}` }
                            }
                        );
                        setQuotaCalls(prev => prev + 1);
                    }
                    await DriveAPI.uploadFile(accessToken, folderId, 'deleted.json', deletedBlob);
                    
                    
                    // STEP 3: Upload local songs
                    const localSongs = [];
                    for (const playlist of mergedPlaylists) {
                        for (const song of playlist.songs) {
                            if (!song.isUrl) {
                                const songData = await DB.get('songs', song.id);
                                if (songData?.blob) {
                                    localSongs.push({
                                        id: song.id,
                                        name: song.name,
                                        blob: songData.blob,
                                        size: songData.blob.size,
                                        playlistId: playlist.id
                                    });
                                }
                            }
                        }
                    }
                    
                    setSyncStatus(`Uploading songs...`);
                    let uploadCount = 0;
                    
                    for (const song of localSongs) {
                        if (cancelSync) throw new Error('Sync cancelled by user');
                        
                        const fileName = createFileName(song.name, song.id);
                        const exists = driveFiles.files?.find(f => 
                            f.name === fileName && 
                            Math.abs(f.size - song.size) < 1024
                        );
                        
                        if (!exists) {
                            setSyncStatus(`Uploading: ${song.name}...`);
                            await DriveAPI.uploadFile(accessToken, folderId, fileName, song.blob);
                            uploadCount++;
                        }
                    }
                    
                    if (cancelSync) throw new Error('Sync cancelled by user');
                    
                    // Update local state with merged playlists
                    setPlaylists(mergedPlaylists);
                    
                    // Fix activePlaylist if it no longer exists
                    if (activePlaylist && !mergedPlaylists.find(p => p.id === activePlaylist)) {
                        console.log('ðŸ” [SYNC DEBUG] Active playlist no longer exists, resetting to first');
                        if (mergedPlaylists.length > 0) {
                            setActivePlaylist(mergedPlaylists[0].id);
                            setView('home'); // Go to home to show all playlists
                        } else {
                            setActivePlaylist(null);
                            setView('home');
                        }
                    }
                    
                    // Sync quota to Drive and get total
                    setSyncStatus('Syncing quota...');
                    const totalQuota = await syncQuotaToUpload(folderId, quotaCalls);
                    setQuotaCalls(totalQuota);
                    
                    setSyncStatus('Sync complete!');
                    
                    console.log('ðŸ” [SYNC DEBUG] Final merged playlists:', mergedPlaylists.map(p => p.name));
                    console.log('ðŸ” [SYNC DEBUG] Uploaded to Drive:', playlistsMetadata.map(p => p.name));
                    console.log('ðŸ” [SYNC DEBUG] Upload count:', uploadCount, 'Download count:', downloadCount);
                    
                    alert(`âœ… Sync Complete!\n\nUploaded: ${uploadCount} songs\nDownloaded: ${downloadCount} songs\n\nYour playlists are synced!\n\nTotal API calls today: ${totalQuota}/20,000`);
                    
                } catch (error) {
                    console.error('Sync error:', error);
                    if (error.message === 'Sync cancelled by user') {
                        alert(`ðŸš« Sync Cancelled`);
                    } else {
                        alert(`âŒ Sync failed: ${error.message}\n\nPlease try again.`);
                    }
                } finally {
                    setSyncing(false);
                    setSyncStatus('');
                    setCancelSync(false);
                }
            };

            const createPlaylist = () => {
                setModalInput('');
                setShowModal('create');
            };

            const goToHome = () => {
                setView('home');
                setSidebarOpen(false);
            };

            const openPlaylist = (id) => {
                setActivePlaylist(id);
                setView('playlist');
                setSidebarOpen(false);
            };

            const handleCreate = async () => {
                if (modalInput.trim()) {
                    debugLog('Creating playlist:', modalInput);
                    const id = Math.floor(Date.now()); // Force integer
                    const newPlaylist = { id, name: modalInput.trim(), songs: [], createdAt: id };
                    
                    await DB.save('playlists', newPlaylist);
                    
                    // Sync to Firebase if connected
                    if (firebaseUserId) {
                        await FirebaseDB.savePlaylist(firebaseUserId, `pl_${id}`, {
                            name: newPlaylist.name,
                            createdAt: id
                        });
                        debugLog('âœ… Playlist synced to Firebase');
                    } else {
                        debugLog('âš ï¸ Not synced to Firebase - firebaseUserId is null');
                        debugLog('âš ï¸ Make sure you clicked "Sign in with Google"');
                    }
                    
                    setPlaylists([...playlists, newPlaylist]);
                    openPlaylist(id);
                    setShowModal(null);
                    debugLog('Playlist created and saved');
                }
            };

            const duplicatePlaylist = async (playlist) => {
                debugLog('Duplicating playlist:', playlist.name);
                const id = Date.now();
                const newPlaylist = { 
                    id, 
                    name: `${playlist.name} (Copy)`, 
                    songs: [...playlist.songs] 
                };
                
                // Save immediately
                await DB.save('playlists', newPlaylist);
                
                setPlaylists([...playlists, newPlaylist]);
                setContextMenu(null);
                
                debugLog('Playlist duplicated and saved');
            };

            const deletePlaylist = async (id) => {
                debugLog('Deleting playlist:', id);
                const p = playlists.find(x => x.id === id);
                if (p) {
                    // Delete all songs
                    for (const s of p.songs) {
                        // Delete from local cache
                        if (!s.isUrl) {
                            await DB.delete('songs', s.id);
                        }
                        
                        // Delete from Google Drive
                        if (s.driveFileId && isSignedIn && accessToken) {
                            try {
                                await fetch(
                                    `https://www.googleapis.com/drive/v3/files/${s.driveFileId}`,
                                    {
                                        method: 'DELETE',
                                        headers: { 'Authorization': `Bearer ${accessToken}` }
                                    }
                                );
                                debugLog('âœ… Deleted song from Drive:', s.driveFileId);
                            } catch (error) {
                                console.error('Failed to delete from Drive:', error);
                            }
                        }
                    }
                    
                    // Delete from IndexedDB
                    await DB.delete('playlists', id);
                    
                    // Delete from Firebase if connected
                    if (firebaseUserId) {
                        await FirebaseDB.deletePlaylist(firebaseUserId, `pl_${id}`);
                        debugLog('âœ… Deleted playlist from Firebase');
                    }
                    
                    // Track deletion
                    const deletedData = await DB.get('settings', 'deletedItems') || { key: 'deletedItems', value: { playlists: [], songs: {} } };
                    if (!deletedData.value.playlists) deletedData.value.playlists = [];
                    if (!deletedData.value.playlists.includes(p.name)) {
                        deletedData.value.playlists.push(p.name);
                        await DB.save('settings', deletedData);
                    }
                }
                
                const newPlaylists = playlists.filter(x => x.id !== id);
                setPlaylists(newPlaylists);
                
                if (activePlaylist === id) {
                    setActivePlaylist(newPlaylists.length > 0 ? newPlaylists[0].id : null);
                }
                
                setContextMenu(null);
                setShowModal(null);
                
                debugLog('Playlist deleted');
            };

            const handleFileUpload = async (e) => {
                if (!activePlaylist) {
                    alert('Please select a playlist first');
                    return;
                }
                
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                debugLog('Uploading files:', files.length);
                
                const playlist = playlists.find(p => p.id === activePlaylist);
                if (!playlist) return;

                for (const file of files) {
                    debugLog('Processing file:', file.name);
                    const shortId = generateShortId(); // Generate 4-char ID
                    const songName = file.name.replace(/\.[^/.]+$/, '');
                    
                    let driveFileId = null;
                    
                    // Upload to Google Drive if signed in
                    if (isSignedIn && accessToken) {
                        try {
                            setSyncStatus(`Uploading ${songName} to Drive...`);
                            
                            const folderId = await DriveAPI.ensureFolder(accessToken);
                            const fileName = `${songName}-${shortId}${file.name.match(/\.[^/.]+$/)?.[0] || '.mp3'}`;
                            const uploadResponse = await DriveAPI.uploadFile(accessToken, folderId, fileName, file);
                            driveFileId = uploadResponse.id; // Extract just the ID string
                            
                            debugLog('âœ… Uploaded to Drive:', driveFileId);
                            setSyncStatus('');
                        } catch (error) {
                            console.error('Drive upload failed:', error);
                            setSyncStatus('');
                            // Continue - save locally anyway
                        }
                    }
                    
                    const song = { 
                        id: shortId, 
                        name: songName, 
                        isUrl: false,
                        driveFileId: driveFileId
                    };
                    
                    // Always save to IndexedDB for offline/cache
                    await DB.save('songs', { id: shortId, blob: file });
                    playlist.songs.push(song);
                    
                    // Sync to Firebase if connected
                    if (firebaseUserId) {
                        await FirebaseDB.saveSong(firebaseUserId, `pl_${activePlaylist}`, shortId, {
                            name: songName,
                            driveFileId: driveFileId,
                            isUrl: false,
                            position: playlist.songs.length - 1,
                            createdAt: Date.now()
                        });
                        debugLog('âœ… Synced to Firebase');
                    } else {
                        debugLog('âš ï¸ Song NOT synced to Firebase - firebaseUserId is null');
                    }
                }
                
                // Save playlist immediately
                await DB.save('playlists', playlist);
                
                setPlaylists([...playlists]);
                
                if (fileInputRef.current) {
                    fileInputRef.current.value = '';
                }
                
                debugLog('Files uploaded and saved');
            };

            const handleUrlSubmit = async () => {
                if (!modalInput.trim() || !activePlaylist) return;
                
                try { 
                    new URL(modalInput); 
                } catch { 
                    alert('Invalid URL. Please enter a valid audio URL.');
                    return; 
                }
                
                debugLog('Adding URL:', modalInput);
                
                const playlist = playlists.find(p => p.id === activePlaylist);
                if (!playlist) return;
                
                const filename = modalInput.split('/').pop().split('?')[0] || 'Audio';
                const songId = generateShortId();
                const songName = filename.replace(/\.[^/.]+$/, '');
                
                const newSong = {
                    id: songId,
                    name: songName,
                    url: modalInput,
                    isUrl: true
                };
                
                playlist.songs.push(newSong);
                
                // Save playlist immediately
                await DB.save('playlists', playlist);
                
                // Sync to Firebase if connected
                if (firebaseUserId) {
                    await FirebaseDB.saveSong(firebaseUserId, `pl_${activePlaylist}`, songId, {
                        name: songName,
                        driveFileId: null,
                        isUrl: true,
                        url: modalInput,
                        position: playlist.songs.length - 1,
                        createdAt: Date.now()
                    });
                    debugLog('âœ… URL synced to Firebase');
                }
                
                setPlaylists([...playlists]);
                setModalInput('');
                setShowModal(null);
                
                debugLog('URL added and saved');
            };

            const playSong = async (song, pid) => {
                if (song.isUrl) {
                    setCurrentSong({ ...song, playlistId: pid });
                    setIsPlaying(true);
                } else {
                    // Try to get from local cache first
                    const data = await DB.get('songs', song.id);
                    if (data?.blob) {
                        // Found in cache - play it!
                        const url = URL.createObjectURL(data.blob);
                        setCurrentSong({ ...song, playlistId: pid, url });
                        setIsPlaying(true);
                    } else {
                        // Not in cache - try to download from Google Drive
                        if (song.driveFileId && isSignedIn && accessToken) {
                            try {
                                setSyncStatus(`Downloading ${song.name}...`);
                                
                                const blob = await DriveAPI.downloadFile(accessToken, song.driveFileId);
                                
                                // Save to cache for next time
                                await DB.save('songs', { id: song.id, blob: blob });
                                
                                const url = URL.createObjectURL(blob);
                                setCurrentSong({ ...song, playlistId: pid, url });
                                setIsPlaying(true);
                                setSyncStatus('');
                                
                                debugLog('âœ… Downloaded and cached from Drive:', song.name);
                            } catch (error) {
                                console.error('Failed to download from Drive:', error);
                                setSyncStatus('');
                                alert(`Failed to download ${song.name} from Drive.\n\nMake sure you're signed in to Google Drive.`);
                            }
                        } else {
                            alert(`${song.name} is not available locally.\n\nSign in to Google Drive to download it.`);
                        }
                    }
                }
            };

            const playNext = () => {
                if (!currentSong) return;
                const p = playlists.find(x => x.id === currentSong.playlistId);
                if (p && p.songs.length > 0) {
                    const idx = p.songs.findIndex(s => s.id === currentSong.id);
                    const nextIdx = (idx + 1) % p.songs.length;
                    playSong(p.songs[nextIdx], p.id);
                }
            };

            const playPrevious = () => {
                if (!currentSong) return;
                const p = playlists.find(x => x.id === currentSong.playlistId);
                if (p && p.songs.length > 0) {
                    const idx = p.songs.findIndex(s => s.id === currentSong.id);
                    const prevIdx = idx === 0 ? p.songs.length - 1 : idx - 1;
                    playSong(p.songs[prevIdx], p.id);
                }
            };

            const deleteSong = async (id, pid) => {
                debugLog('Deleting song:', id);
                const p = playlists.find(x => x.id === pid);
                if (p) {
                    const s = p.songs.find(x => x.id === id);
                    
                    // Delete from local cache
                    if (s && !s.isUrl) {
                        await DB.delete('songs', s.id);
                    }
                    
                    // Delete from Google Drive if it has a driveFileId
                    if (s && s.driveFileId && isSignedIn && accessToken) {
                        try {
                            await fetch(
                                `https://www.googleapis.com/drive/v3/files/${s.driveFileId}`,
                                {
                                    method: 'DELETE',
                                    headers: { 'Authorization': `Bearer ${accessToken}` }
                                }
                            );
                            debugLog('âœ… Deleted from Google Drive:', s.driveFileId);
                        } catch (error) {
                            console.error('Failed to delete from Drive:', error);
                        }
                    }
                    
                    // Delete from Firebase if connected
                    if (firebaseUserId) {
                        await FirebaseDB.deleteSong(firebaseUserId, `pl_${pid}`, id);
                        debugLog('âœ… Deleted from Firebase');
                    }
                    
                    p.songs = p.songs.filter(x => x.id !== id);
                    
                    // Track deletion
                    const deletedData = await DB.get('settings', 'deletedItems') || { key: 'deletedItems', value: { playlists: [], songs: {} } };
                    if (!deletedData.value.songs) deletedData.value.songs = {};
                    if (!deletedData.value.songs[p.name]) deletedData.value.songs[p.name] = [];
                    if (!deletedData.value.songs[p.name].includes(id)) {
                        deletedData.value.songs[p.name].push(id);
                        await DB.save('settings', deletedData);
                    }
                    
                    // Save playlist immediately
                    await DB.save('playlists', p);
                    
                    setPlaylists([...playlists]);
                }
                setShowModal(null);
                debugLog('Song deleted');
            };

            const exportData = () => {
                const blob = new Blob([JSON.stringify(playlists, null, 2)], { 
                    type: 'application/json' 
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `music-backup-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const importData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        if (Array.isArray(data)) {
                            // Save all imported playlists immediately
                            for (const playlist of data) {
                                await DB.save('playlists', playlist);
                            }
                            setPlaylists([...playlists, ...data]);
                        }
                    } catch { 
                        alert('Invalid backup file'); 
                    }
                };
                reader.readAsText(file);
            };

            const startEditingPlaylist = (playlist) => {
                setEditingPlaylist(playlist.id);
                setEditingPlaylistName(playlist.name);
            };

            const saveEditingPlaylist = async () => {
                if (!editingPlaylist || !editingPlaylistName.trim()) {
                    setEditingPlaylist(null);
                    return;
                }
                
                const playlist = playlists.find(p => p.id === editingPlaylist);
                if (playlist) {
                    playlist.name = editingPlaylistName.trim();
                    await DB.save('playlists', playlist);
                    setPlaylists([...playlists]);
                    debugLog('Playlist name updated:', editingPlaylistName);
                }
                
                setEditingPlaylist(null);
                setEditingPlaylistName('');
            };

            const cancelEditingPlaylist = () => {
                setEditingPlaylist(null);
                setEditingPlaylistName('');
            };

            const handlePlaylistLongPressStart = (playlist) => {
                longPressTimer.current = setTimeout(() => {
                    startEditingPlaylist(playlist);
                }, 500);
            };

            const handlePlaylistLongPressEnd = () => {
                if (longPressTimer.current) {
                    clearTimeout(longPressTimer.current);
                }
            };

            const startEditingSong = (song) => {
                setEditingSong(song.id);
                setEditingSongName(song.name);
            };

            const saveEditingSong = async () => {
                if (!editingSong || !editingSongName.trim()) {
                    setEditingSong(null);
                    return;
                }
                
                const playlist = playlists.find(p => p.id === activePlaylist);
                if (playlist) {
                    const song = playlist.songs.find(s => s.id === editingSong);
                    if (song) {
                        song.name = editingSongName.trim();
                        await DB.save('playlists', playlist);
                        setPlaylists([...playlists]);
                        debugLog('Song name updated:', editingSongName);
                    }
                }
                
                setEditingSong(null);
                setEditingSongName('');
            };

            const cancelEditingSong = () => {
                setEditingSong(null);
                setEditingSongName('');
            };

            const handleSongLongPressStart = (song) => {
                longPressTimer.current = setTimeout(() => {
                    startEditingSong(song);
                }, 500);
            };

            const handleSongLongPressEnd = () => {
                if (longPressTimer.current) {
                    clearTimeout(longPressTimer.current);
                }
            };

            // Google Drive API Helpers
            const DriveAPI = {
                async trackCall() {
                    const today = new Date().toDateString();
                    
                    // Get stored quota data
                    const quotaData = await DB.get('settings', 'quotaTracking');
                    
                    let currentCount = 1;
                    
                    if (quotaData?.value) {
                        const { date, count } = quotaData.value;
                        
                        if (date === today) {
                            // Same day - increment
                            currentCount = count + 1;
                        } else {
                            // New day - reset to 1
                            currentCount = 1;
                        }
                    }
                    
                    // Save updated count
                    await DB.save('settings', {
                        key: 'quotaTracking',
                        value: { date: today, count: currentCount }
                    });
                    
                    setQuotaCalls(currentCount);
                },
                
                async ensureFolder(accessToken) {
                    this.trackCall();
                    const searchResponse = await fetch(
                        `https://www.googleapis.com/drive/v3/files?q=name='MusicPlayer' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                        { headers: { 'Authorization': `Bearer ${accessToken}` } }
                    );
                    const searchData = await searchResponse.json();
                    
                    if (searchData.files && searchData.files.length > 0) {
                        return searchData.files[0].id;
                    }
                    
                    this.trackCall();
                    const createResponse = await fetch(
                        'https://www.googleapis.com/drive/v3/files',
                        {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${accessToken}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                name: 'MusicPlayer',
                                mimeType: 'application/vnd.google-apps.folder'
                            })
                        }
                    );
                    const folder = await createResponse.json();
                    return folder.id;
                },
                
                async listFiles(accessToken, folderId) {
                    this.trackCall();
                    const response = await fetch(
                        `https://www.googleapis.com/drive/v3/files?q='${folderId}' in parents and trashed=false&fields=files(id,name,size,modifiedTime)`,
                        { headers: { 'Authorization': `Bearer ${accessToken}` } }
                    );
                    return await response.json();
                },
                
                async uploadFile(accessToken, folderId, fileName, fileBlob) {
                    this.trackCall();
                    const metadata = { name: fileName, parents: [folderId] };
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                    form.append('file', fileBlob);
                    
                    const response = await fetch(
                        'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,size',
                        {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${accessToken}` },
                            body: form
                        }
                    );
                    return await response.json();
                },
                
                async downloadFile(accessToken, fileId) {
                    this.trackCall();
                    const response = await fetch(
                        `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
                        { headers: { 'Authorization': `Bearer ${accessToken}` } }
                    );
                    return await response.blob();
                }
            };

            // Quota syncing functions
            const syncQuotaToUpload = async (folderId, deviceCalls) => {
                try {
                    const today = new Date().toDateString();
                    const deviceId = await getDeviceId();
                    
                    // Download existing quota.json
                    const driveFiles = await DriveAPI.listFiles(accessToken, folderId);
                    const quotaFile = driveFiles.files?.find(f => f.name === 'quota.json');
                    
                    let quotaData = { date: today, totalCalls: 0, devices: {} };
                    
                    if (quotaFile) {
                        const blob = await DriveAPI.downloadFile(accessToken, quotaFile.id);
                        const text = await blob.text();
                        quotaData = JSON.parse(text);
                        
                        // Check if new day
                        if (quotaData.date !== today) {
                            quotaData = { date: today, totalCalls: 0, devices: {} };
                        }
                        
                        // Delete old quota file
                        await fetch(
                            `https://www.googleapis.com/drive/v3/files/${quotaFile.id}`,
                            {
                                method: 'DELETE',
                                headers: { 'Authorization': `Bearer ${accessToken}` }
                            }
                        );
                    }
                    
                    // Update this device's calls
                    quotaData.devices[deviceId] = deviceCalls;
                    quotaData.totalCalls = Object.values(quotaData.devices).reduce((a, b) => a + b, 0);
                    
                    // Upload new quota.json
                    const quotaBlob = new Blob([JSON.stringify(quotaData, null, 2)], { type: 'application/json' });
                    await DriveAPI.uploadFile(accessToken, folderId, 'quota.json', quotaBlob);
                    
                    return quotaData.totalCalls;
                } catch (e) {
                    console.error('Quota sync error:', e);
                    return deviceCalls; // Fallback to local count
                }
            };
            
            const syncQuotaFromDownload = async (folderId) => {
                try {
                    const today = new Date().toDateString();
                    const driveFiles = await DriveAPI.listFiles(accessToken, folderId);
                    const quotaFile = driveFiles.files?.find(f => f.name === 'quota.json');
                    
                    if (quotaFile) {
                        const blob = await DriveAPI.downloadFile(accessToken, quotaFile.id);
                        const text = await blob.text();
                        const quotaData = JSON.parse(text);
                        
                        if (quotaData.date === today) {
                            return quotaData.totalCalls;
                        }
                    }
                    return 0;
                } catch (e) {
                    console.error('Quota download error:', e);
                    return 0;
                }
            };
            
            const getDeviceId = async () => {
                let deviceId = await DB.get('settings', 'deviceId');
                if (!deviceId) {
                    deviceId = { key: 'deviceId', value: generateShortId() + generateShortId() };
                    await DB.save('settings', deviceId);
                }
                return deviceId.value;
            };

            // Generate short 4-character ID
            const generateShortId = () => {
                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                let id = '';
                for (let i = 0; i < 4; i++) {
                    id += chars[Math.floor(Math.random() * chars.length)];
                }
                return id;
            };
            
            // Create filename from song name and ID
            const createFileName = (songName, songId) => {
                // Clean song name (remove invalid chars)
                const cleanName = songName.replace(/[<>:"/\\|?*]/g, '-').trim();
                return `${cleanName}-${songId}.mp3`;
            };
            
            // Extract song ID from filename
            const extractIdFromFileName = (fileName) => {
                // Format: "Song Name-a3f2.mp3"
                const match = fileName.match(/-([a-z0-9]{4})\.mp3$/i);
                return match ? match[1] : null;
            };

            const formatTime = (s) => {
                if (!s || isNaN(s)) return '0:00';
                const m = Math.floor(s / 60);
                const sec = Math.floor(s % 60);
                return `${m}:${sec.toString().padStart(2, '0')}`;
            };

            // Drag and drop for playlists
            const handlePlaylistDragStart = (e, index) => {
                setDraggedPlaylist(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handlePlaylistDragOver = (e, index) => {
                e.preventDefault();
                if (draggedPlaylist === null || draggedPlaylist === index) return;
                
                const newPlaylists = [...playlists];
                const draggedItem = newPlaylists[draggedPlaylist];
                newPlaylists.splice(draggedPlaylist, 1);
                newPlaylists.splice(index, 0, draggedItem);
                
                setPlaylists(newPlaylists);
                setDraggedPlaylist(index);
            };

            const handlePlaylistDragEnd = () => {
                setDraggedPlaylist(null);
            };

            // Drag and drop for songs
            const handleSongDragStart = (e, index) => {
                setDraggedSong(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleSongDragOver = (e, index) => {
                e.preventDefault();
                
                // For touch drag, use touchDragIndex; for mouse drag, use draggedSong
                const currentDragIndex = touchDragIndex !== null ? touchDragIndex : draggedSong;
                
                if (currentDragIndex === null || currentDragIndex === index) {
                    console.log('Skipping - already at this position or not dragging');
                    return;
                }
                
                console.log('handleSongDragOver executing: moving from', currentDragIndex, 'to', index);
                
                const playlist = playlists.find(p => p.id === activePlaylist);
                if (!playlist) return;
                
                const newSongs = [...playlist.songs];
                const draggedItem = newSongs[currentDragIndex];
                newSongs.splice(currentDragIndex, 1);
                newSongs.splice(index, 0, draggedItem);
                
                playlist.songs = newSongs;
                setPlaylists([...playlists]);
                setDraggedSong(index);
                
                console.log('Reorder complete - new song order:', newSongs.map(s => s.name));
            };

            const handleSongDragEnd = async () => {
                // Save the reordered playlist to database
                if (draggedSong !== null && activePlaylist) {
                    const playlist = playlists.find(p => p.id === activePlaylist);
                    if (playlist) {
                        await DB.save('playlists', playlist);
                        debugLog('Song order saved to DB');
                    }
                }
                setDraggedSong(null);
            };
            
            // Touch drag for mobile
            const [touchDragY, setTouchDragY] = useState(null);
            const [touchDragIndex, setTouchDragIndex] = useState(null);
            const dragHandleTimer = useRef(null);
            const [isDraggingTouch, setIsDraggingTouch] = useState(false);
            
            const handleSongTouchStart = (e, index) => {
                e.preventDefault(); // Prevent text selection
                console.log('Touch start on song index:', index);
                const touch = e.touches[0];
                setTouchDragY(touch.clientY);
                
                // Store reference to the touched element
                const touchedElement = e.currentTarget.parentElement;
                
                // Long-press timer: wait 300ms before enabling drag (reduced from 500ms)
                dragHandleTimer.current = setTimeout(() => {
                    console.log('Long press activated! Starting drag for index:', index);
                    
                    // Add visual feedback immediately via DOM
                    touchedElement.style.opacity = '0.5';
                    touchedElement.style.transform = 'scale(1.02)';
                    
                    setTouchDragIndex(index);
                    setDraggedSong(index);
                    setIsDraggingTouch(true);
                }, 300);
            };
            
            const handleSongTouchMove = (e, index) => {
                console.log('TouchMove fired! isDraggingTouch:', isDraggingTouch, 'touchDragIndex:', touchDragIndex);
                
                if (!isDraggingTouch || touchDragIndex === null) {
                    // Cancel long-press if user moves before 300ms
                    if (dragHandleTimer.current) {
                        clearTimeout(dragHandleTimer.current);
                        console.log('Cancelled long-press because moved too early');
                    }
                    return;
                }
                
                console.log('Touch move - ACTIVE DRAG');
                e.preventDefault();
                
                const touch = e.touches[0];
                const fingerY = touch.clientY;
                
                // Find which song item the finger is currently over
                const songElements = document.querySelectorAll('.song-item');
                let targetIndex = touchDragIndex; // Default to current position
                
                console.log('Found', songElements.length, 'song items');
                
                songElements.forEach((element, idx) => {
                    const rect = element.getBoundingClientRect();
                    const itemMiddle = rect.top + rect.height / 2;
                    
                    // If finger is over this item's middle point
                    if (fingerY >= rect.top && fingerY <= rect.bottom) {
                        targetIndex = idx;
                        console.log('Finger over item', idx, 'at Y:', fingerY);
                    }
                });
                
                console.log('Target index:', targetIndex, 'Current drag index:', touchDragIndex);
                console.log('Are they different?', targetIndex !== touchDragIndex);
                console.log('Target >= 0?', targetIndex >= 0);
                console.log('Current songs length:', current?.songs?.length);
                console.log('Target < length?', targetIndex < current?.songs.length);
                
                // If finger moved to a different position, reorder
                if (targetIndex !== touchDragIndex && targetIndex >= 0 && targetIndex < current?.songs.length) {
                    console.log('Ã¢Å“â€¦ ALL CONDITIONS MET! Reordering from', touchDragIndex, 'to', targetIndex);
                    handleSongDragOver(e, targetIndex);
                    setTouchDragIndex(targetIndex);
                } else {
                    console.log('Ã¢ÂÅ’ Reorder blocked. targetIndex:', targetIndex, 'touchDragIndex:', touchDragIndex, 'songs.length:', current?.songs?.length);
                }
            };
            
            const handleSongTouchEnd = () => {
                if (dragHandleTimer.current) {
                    clearTimeout(dragHandleTimer.current);
                }
                
                // Remove visual feedback from all items
                document.querySelectorAll('.song-item').forEach(el => {
                    el.style.opacity = '';
                    el.style.transform = '';
                });
                
                setTouchDragY(null);
                setTouchDragIndex(null);
                setIsDraggingTouch(false);
                handleSongDragEnd();
            };

            const current = playlists.find(p => p.id === activePlaylist);
            const recentPlaylist = playlists.find(p => p.id === recentPlaylistId);
            const filtered = playlists.filter(p => 
                p.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                p.songs.some(s => s.name.toLowerCase().includes(searchQuery.toLowerCase()))
            );

            // Welcome Page (first-time users only)
            if (showWelcome) {
                return React.createElement('div', { 
                    className: bg,
                    style: { 
                        height: '100vh', 
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center', 
                        padding: '20px' 
                    } 
                },
                    React.createElement('div', { 
                        style: { 
                            textAlign: 'center', 
                            maxWidth: '450px',
                            padding: '40px 30px',
                            background: darkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.02)',
                            borderRadius: '20px',
                            backdropFilter: 'blur(10px)',
                            position: 'relative'
                        } 
                    },
                        // Language + theme toggle in top right
                        React.createElement('div', { 
                            style: { 
                                position: 'absolute',
                                top: '20px',
                                right: '20px',
                                display: 'flex',
                                gap: '8px',
                                alignItems: 'center'
                            }
                        },
                            // Language buttons
                            React.createElement('button', {
                                onClick: () => setLanguage('zh'),
                                style: {
                                    padding: '4px 10px',
                                    fontSize: '12px',
                                    fontWeight: language === 'zh' ? '700' : '500',
                                    background: language === 'zh' ? (darkMode ? 'rgba(29, 185, 84, 0.2)' : 'rgba(29, 185, 84, 0.15)') : 'transparent',
                                    color: language === 'zh' ? '#1DB954' : (darkMode ? '#b3b3b3' : '#666'),
                                    border: language === 'zh' ? '1px solid #1DB954' : `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                    borderRadius: '6px',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s'
                                }
                            }, 'ä¸­'),
                            React.createElement('button', {
                                onClick: () => setLanguage('en'),
                                style: {
                                    padding: '4px 10px',
                                    fontSize: '12px',
                                    fontWeight: language === 'en' ? '700' : '500',
                                    background: language === 'en' ? (darkMode ? 'rgba(29, 185, 84, 0.2)' : 'rgba(29, 185, 84, 0.15)') : 'transparent',
                                    color: language === 'en' ? '#1DB954' : (darkMode ? '#b3b3b3' : '#666'),
                                    border: language === 'en' ? '1px solid #1DB954' : `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                    borderRadius: '6px',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s'
                                }
                            }, 'EN'),
                            // Theme toggle
                            React.createElement('button', {
                                onClick: () => setDarkMode(!darkMode),
                                className: 'icon-btn icon-btn-small',
                                style: { marginLeft: '4px' }
                            }, darkMode ? React.createElement(Icons.Sun) : React.createElement(Icons.Moon))
                        ),
                        
                        React.createElement('div', { 
                            style: { fontSize: '48px', marginBottom: '16px' } 
                        }, 'ðŸŽµ'),
                        
                        React.createElement('h1', { 
                            className: 'text-color',
                            style: { 
                                fontSize: '32px', 
                                fontWeight: 'bold', 
                                marginBottom: '12px' 
                            } 
                        }, t.welcomeTitle),
                        
                        React.createElement('p', { 
                            className: txtMuted,
                            style: { 
                                fontSize: '16px', 
                                marginBottom: '40px',
                                lineHeight: '1.6'
                            } 
                        }, t.welcomeSubtitle),
                        
                        // Sign in with Google button
                        React.createElement('button', { 
                            onClick: () => {
                                localStorage.setItem('hasSeenWelcome', 'true');
                                setShowWelcome(false);
                                // Trigger Google sign-in
                                setTimeout(() => {
                                    document.querySelector('[aria-label="Sign in with Google"]')?.click();
                                }, 100);
                            },
                            style: { 
                                width: '100%',
                                padding: '16px 24px',
                                fontSize: '16px',
                                fontWeight: '600',
                                marginBottom: '16px',
                                background: 'linear-gradient(135deg, #4285f4 0%, #34a853 100%)',
                                color: '#ffffff',
                                border: 'none',
                                borderRadius: '12px',
                                cursor: 'pointer',
                                boxShadow: '0 4px 12px rgba(66, 133, 244, 0.4)',
                                transition: 'transform 0.2s, box-shadow 0.2s'
                            },
                            onMouseOver: (e) => {
                                e.target.style.transform = 'translateY(-2px)';
                                e.target.style.boxShadow = '0 6px 16px rgba(66, 133, 244, 0.5)';
                            },
                            onMouseOut: (e) => {
                                e.target.style.transform = 'translateY(0)';
                                e.target.style.boxShadow = '0 4px 12px rgba(66, 133, 244, 0.4)';
                            }
                        }, 
                            React.createElement('span', {}, `ðŸ”¥ ${t.signInGoogle}`),
                            React.createElement('div', { 
                                style: { 
                                    fontSize: '13px', 
                                    opacity: 0.9, 
                                    marginTop: '4px',
                                    fontWeight: 'normal'
                                } 
                            }, t.signInDesc)
                        ),
                        
                        // Guest mode warning
                        React.createElement('div', {
                            style: {
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                gap: '8px',
                                padding: '12px 16px',
                                marginBottom: '16px',
                                background: darkMode ? 'rgba(245, 158, 11, 0.1)' : 'rgba(245, 158, 11, 0.08)',
                                border: `1px solid ${darkMode ? 'rgba(245, 158, 11, 0.3)' : 'rgba(245, 158, 11, 0.2)'}`,
                                borderRadius: '8px',
                                fontSize: '13px',
                                color: darkMode ? '#fbbf24' : '#d97706',
                                lineHeight: '1.4'
                            }
                        },
                            React.createElement('span', { style: { fontSize: '16px' } }, 'â„¹ï¸'),
                            React.createElement('span', {}, t.guestWarning)
                        ),
                        
                        // Continue as Guest button
                        React.createElement('button', {
                            onClick: () => {
                                localStorage.setItem('hasSeenWelcome', 'true');
                                setShowWelcome(false);
                                setLoading(false);
                            },
                            style: { 
                                width: '100%',
                                padding: '16px 24px',
                                fontSize: '16px',
                                fontWeight: '600',
                                background: darkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)',
                                color: darkMode ? '#ffffff' : '#000000',
                                border: darkMode ? '1px solid rgba(255, 255, 255, 0.2)' : '1px solid rgba(0, 0, 0, 0.1)',
                                borderRadius: '12px',
                                cursor: 'pointer',
                                transition: 'all 0.2s'
                            },
                            onMouseOver: (e) => {
                                e.target.style.background = darkMode ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.08)';
                            },
                            onMouseOut: (e) => {
                                e.target.style.background = darkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
                            }
                        }, 
                            React.createElement('span', {}, `ðŸ“± ${t.continueGuest}`),
                            React.createElement('div', { 
                                style: { 
                                    fontSize: '13px', 
                                    opacity: 0.7, 
                                    marginTop: '4px',
                                    fontWeight: 'normal'
                                } 
                            }, t.continueDesc)
                        )
                    )
                );
            }

            // FIXED: Better loading state
            if (loading) {
                return React.createElement('div', { className: 'loading-overlay' },
                    React.createElement('div', { className: 'spinner' }),
                    React.createElement('div', { style: { marginTop: '20px', fontSize: '18px' } }, t.loadingLibrary),
                    React.createElement('div', { style: { marginTop: '8px', fontSize: '14px', opacity: 0.7 } }, t.pleaseWait)
                );
            }

            
            // Show modal even if no playlists
            if (playlists.length === 0 && showModal === 'create') {
                return React.createElement('div', { className: bg, style: { height: '100vh' } },
                    // Create Playlist Modal
                    React.createElement('div', { 
                        className: 'modal-overlay',
                        onClick: (e) => {
                            if (e.target === e.currentTarget) setShowModal(null);
                        }
                    },
                        React.createElement('div', { className: `modal ${modalClass}` },
                            React.createElement('div', { 
                                className: 'text-2xl font-bold mb-4' 
                            }, 'Create Your First Playlist'),
                            React.createElement('input', {
                                type: 'text',
                                value: modalInput,
                                onChange: (e) => setModalInput(e.target.value),
                                placeholder: t.playlistName,
                                className: 'mb-4',
                                onKeyPress: (e) => e.key === 'Enter' && handleCreate(),
                                autoFocus: true,
                                style: {
                                    background: darkMode ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.05)',
                                    border: `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                    color: darkMode ? '#fff' : '#1a1a1a'
                                }
                            }),
                            React.createElement('div', { 
                                className: 'flex gap-3', 
                                style: { justifyContent: 'flex-end' } 
                            },
                                React.createElement('button', { 
                                    onClick: () => setShowModal(null), 
                                    className: 'btn-secondary',
                                style: { color: darkMode ? '#ffffff' : '#000000' }
                                }, t.cancel),
                                React.createElement('button', { 
                                    onClick: handleCreate, 
                                    className: 'btn-primary' 
                                }, t.create)
                            )
                        )
                    )
                );
            }

            return React.createElement('div', null,
                // Offline banner
                !isOnline && React.createElement('div', { className: 'offline-banner' },
                    t.offlineMode
                ),
                
                // Audio element
                React.createElement('audio', {
                    ref: audioRef,
                    onTimeUpdate: (e) => {
                        if (e.target.duration) {
                            setProgress((e.target.currentTime / e.target.duration) * 100);
                        }
                    },
                    onEnded: () => {
                        console.log('Ã°Å¸Å½Âµ Song ended. Repeat state:', repeat);
                        console.log('audioRef.current exists?', !!audioRef.current);
                        
                        if (repeat) {
                            console.log('Ã¢Å“â€¦ Repeat is enabled, attempting to replay...');
                            
                            // Mobile-friendly repeat: handle play promise
                            if (audioRef.current) {
                                console.log('Setting currentTime to 0');
                                audioRef.current.currentTime = 0;
                                
                                console.log('Calling play()...');
                                const playPromise = audioRef.current.play();
                                
                                console.log('Play promise:', playPromise);
                                
                                if (playPromise !== undefined) {
                                    playPromise
                                        .then(() => {
                                            console.log('Ã¢Å“â€¦ Play succeeded!');
                                        })
                                        .catch(err => {
                                            console.log('Ã¢ÂÅ’ Repeat play error (mobile):', err);
                                            // Try again after a brief delay for mobile
                                            setTimeout(() => {
                                                console.log('Retrying play after delay...');
                                                if (audioRef.current) {
                                                    audioRef.current.play()
                                                        .then(() => console.log('Ã¢Å“â€¦ Retry succeeded!'))
                                                        .catch(e => console.log('Ã¢ÂÅ’ Retry failed:', e));
                                                }
                                            }, 100);
                                        });
                                }
                            } else {
                                console.log('Ã¢ÂÅ’ audioRef.current is null!');
                            }
                        } else {
                            console.log('Repeat is OFF, calling playNext()');
                            playNext();
                        }
                    }
                }),
                
                // File input - iOS FIXED
                React.createElement('input', {
                    ref: fileInputRef,
                    type: 'file',
                    multiple: true,
                    accept: 'audio/*,.mp3,.m4a,.wav,.aac,.flac,.ogg,.mp4',
                    onChange: handleFileUpload,
                    style: { display: 'none' }
                }),
                
                // Overlay for mobile sidebar
                React.createElement('div', { 
                    className: `overlay ${sidebarOpen ? 'open' : ''}`, 
                    onClick: () => setSidebarOpen(false) 
                }),
                
                // Context Menu
                contextMenu && React.createElement('div', {
                    className: 'context-menu',
                    style: { top: contextMenu.y, left: contextMenu.x },
                    onClick: (e) => e.stopPropagation()
                },
                    React.createElement('div', {
                        className: 'context-menu-item',
                        onClick: () => duplicatePlaylist(contextMenu.playlist)
                    },
                        React.createElement(Icons.Copy),
                        t.duplicate
                    ),
                    React.createElement('div', {
                        className: 'context-menu-item',
                        onClick: () => {
                            setShowModal({ type: 'delete-playlist', id: contextMenu.playlist.id });
                            setContextMenu(null);
                        }
                    },
                        React.createElement(Icons.Trash),
                        t.deleteButton
                    )
                ),
                
                // Main Container
                React.createElement('div', { className: `container ${bg}` },
                    // Sidebar - V6 Simplified
                    React.createElement('div', { 
                        className: `sidebar ${sidebar} ${sidebarOpen ? 'open' : ''}` 
                    },
                        // Guest Mode card or Signed-in state
                        isSignedIn ? (
                            // Signed-in state
                            React.createElement('div', { className: `${card}`, style: { padding: '16px' } },
                                // Language toggle + theme toggle on top
                                React.createElement('div', { className: 'flex items-center justify-between mb-3' },
                                    // Language buttons
                                    React.createElement('div', { className: 'flex gap-2' },
                                        React.createElement('button', {
                                            onClick: () => setLanguage('zh'),
                                            style: {
                                                padding: '4px 10px',
                                                fontSize: '12px',
                                                fontWeight: language === 'zh' ? '700' : '500',
                                                background: language === 'zh' ? (darkMode ? 'rgba(29, 185, 84, 0.2)' : 'rgba(29, 185, 84, 0.15)') : 'transparent',
                                                color: language === 'zh' ? '#1DB954' : (darkMode ? '#b3b3b3' : '#666'),
                                                border: language === 'zh' ? '1px solid #1DB954' : `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                                borderRadius: '6px',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s'
                                            }
                                        }, 'ä¸­'),
                                        React.createElement('button', {
                                            onClick: () => setLanguage('en'),
                                            style: {
                                                padding: '4px 10px',
                                                fontSize: '12px',
                                                fontWeight: language === 'en' ? '700' : '500',
                                                background: language === 'en' ? (darkMode ? 'rgba(29, 185, 84, 0.2)' : 'rgba(29, 185, 84, 0.15)') : 'transparent',
                                                color: language === 'en' ? '#1DB954' : (darkMode ? '#b3b3b3' : '#666'),
                                                border: language === 'en' ? '1px solid #1DB954' : `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                                borderRadius: '6px',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s'
                                            }
                                        }, 'EN')
                                    ),
                                    // Theme toggle
                                    React.createElement('button', {
                                        onClick: () => setDarkMode(!darkMode),
                                        className: `icon-btn icon-btn-small`,
                                        'aria-label': 'Toggle theme'
                                    }, darkMode ? React.createElement(Icons.Sun) : React.createElement(Icons.Moon))
                                ),
                                
                                // User info
                                React.createElement('div', { className: 'mb-4' },
                                    React.createElement('div', { style: { fontSize: '14px', fontWeight: '600' } }, userInfo?.name || 'User'),
                                    React.createElement('div', { style: { fontSize: '12px', opacity: 0.7 } }, userInfo?.email || '')
                                ),
                                
                                // Sync button (BLUE, no icon) or Cancel button
                                syncing ? (
                                    React.createElement('button', { 
                                        onClick: () => setCancelSync(true),
                                        className: 'btn-secondary',
                                        style: { 
                                            width: '100%', 
                                            fontSize: '13px', 
                                            padding: '12px 20px', 
                                            marginBottom: '8px',
                                            background: 'rgba(220, 38, 38, 0.8)',
                                            color: '#ffffff'
                                        }
                                    }, 'âŒ Cancel Sync')
                                ) : (
                                    // Firebase handles sync automatically!
                                    React.createElement('div', { 
                                        style: { 
                                            width: '100%', 
                                            fontSize: '13px', 
                                            padding: '12px 20px', 
                                            marginBottom: '8px',
                                            background: 'rgba(29, 185, 84, 0.1)',
                                            border: '1px solid rgba(29, 185, 84, 0.3)',
                                            borderRadius: '8px',
                                            textAlign: 'center',
                                            color: '#1DB954'
                                        }
                                    }, 'âœ… Auto-Sync Active (Firebase)')
                                ),
                                
                                // Sync status (when syncing)
                                syncing && React.createElement('div', { style: { fontSize: '12px', textAlign: 'center', marginBottom: '8px', color: '#1e90ff' } },
                                    `â³ ${syncStatus}`
                                ),
                                
                                // Quota display
                                React.createElement('div', { style: { fontSize: '12px', textAlign: 'center', opacity: 0.7, marginBottom: '8px' } },
                                    `${t.apiCalls}: ${quotaCalls}/20,000`
                                ),
                                
                                // Sign out button
                                React.createElement('button', { 
                                    onClick: async () => {
                                        setIsSignedIn(false);
                                        setUserInfo(null);
                                        setAccessToken(null);
                                        setFirebaseUserId(null);
                                        setGoogleUserId(null);
                                        setQuotaCalls(0);
                                        await DB.delete('settings', 'googleAuth');
                                        alert(t.signedOut);
                                    },
                                    className: 'btn-secondary',
                                    style: { width: '100%', fontSize: '12px', padding: '8px 16px', color: darkMode ? '#ffffff' : '#000000' }
                                }, t.signOut),
                                
                                // DEBUG INFO PANEL
                                React.createElement('div', { 
                                    style: { 
                                        marginTop: '12px',
                                        padding: '12px',
                                        background: darkMode ? 'rgba(255, 0, 0, 0.1)' : 'rgba(255, 0, 0, 0.05)',
                                        border: '1px solid rgba(255, 0, 0, 0.3)',
                                        borderRadius: '8px',
                                        fontSize: '11px',
                                        fontFamily: 'monospace'
                                    }
                                },
                                    React.createElement('div', { style: { fontWeight: 'bold', marginBottom: '6px', color: '#ff4444' } }, 'ðŸ”§ DEBUG INFO'),
                                    React.createElement('div', {}, `isSignedIn: ${isSignedIn ? 'âœ… YES' : 'âŒ NO'}`),
                                    React.createElement('div', {}, `Google ID: ${googleUserId || 'âŒ NULL'}`),
                                    React.createElement('div', {}, `Firebase UID: ${firebaseUserId || 'âŒ NULL'}`),
                                    React.createElement('div', {}, `accessToken: ${accessToken ? 'âœ… EXISTS' : 'âŒ NULL'}`),
                                    React.createElement('div', {}, `Firebase config: ${isFirebaseConfigured ? 'âœ… YES' : 'âŒ NO'}`),
                                    firebaseError && React.createElement('div', { style: { color: '#ff4444', marginTop: '6px', fontWeight: 'bold' } }, `ðŸ”¥ ERROR: ${firebaseError}`)
                                )
                            )
                        ) : (
                            // Guest Mode
                            React.createElement('div', { className: `${card}`, style: { padding: '16px' } },
                                // Language toggle + theme toggle on top
                                React.createElement('div', { className: 'flex items-center justify-between mb-3' },
                                    // Language buttons
                                    React.createElement('div', { className: 'flex gap-2' },
                                        React.createElement('button', {
                                            onClick: () => setLanguage('zh'),
                                            style: {
                                                padding: '4px 10px',
                                                fontSize: '12px',
                                                fontWeight: language === 'zh' ? '700' : '500',
                                                background: language === 'zh' ? (darkMode ? 'rgba(29, 185, 84, 0.2)' : 'rgba(29, 185, 84, 0.15)') : 'transparent',
                                                color: language === 'zh' ? '#1DB954' : (darkMode ? '#b3b3b3' : '#666'),
                                                border: language === 'zh' ? '1px solid #1DB954' : `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                                borderRadius: '6px',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s'
                                            }
                                        }, 'ä¸­'),
                                        React.createElement('button', {
                                            onClick: () => setLanguage('en'),
                                            style: {
                                                padding: '4px 10px',
                                                fontSize: '12px',
                                                fontWeight: language === 'en' ? '700' : '500',
                                                background: language === 'en' ? (darkMode ? 'rgba(29, 185, 84, 0.2)' : 'rgba(29, 185, 84, 0.15)') : 'transparent',
                                                color: language === 'en' ? '#1DB954' : (darkMode ? '#b3b3b3' : '#666'),
                                                border: language === 'en' ? '1px solid #1DB954' : `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                                borderRadius: '6px',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s'
                                            }
                                        }, 'EN')
                                    ),
                                    // Theme toggle
                                    React.createElement('button', {
                                        onClick: () => setDarkMode(!darkMode),
                                        className: `icon-btn icon-btn-small`,
                                        'aria-label': 'Toggle theme'
                                    }, darkMode ? React.createElement(Icons.Sun) : React.createElement(Icons.Moon))
                                ),
                                
                                // Guest Mode title
                                React.createElement('div', { style: { fontSize: '16px', fontWeight: '600', marginBottom: '16px' } }, t.guestMode),
                                
                                // Full-width sign-in button
                                React.createElement('button', { 
                                    onClick: () => {
                                        const tokenClient = google.accounts.oauth2.initTokenClient({
                                            client_id: '806582188876-ein8g451k0lorgsn3gja2gp53tqmmcqq.apps.googleusercontent.com',
                                            scope: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email',
                                            callback: async (response) => {
                                                if (response.error) {
                                                    console.error('Auth error:', response);
                                                    alert(`Sign-in failed: ${response.error}`);
                                                    return;
                                                }
                                                
                                                const token = response.access_token;
                                                
                                                // Get user info from Google
                                                const userResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                                                    headers: { 'Authorization': `Bearer ${token}` }
                                                });
                                                const user = await userResponse.json();
                                                
                                                // Update Google Drive state
                                                setIsSignedIn(true);
                                                setUserInfo(user);
                                                setAccessToken(token);
                                                
                                                // Save to IndexedDB
                                                await DB.save('settings', { 
                                                    key: 'googleAuth', 
                                                    value: { 
                                                        userInfo: user, 
                                                        accessToken: token, 
                                                        expiresAt: Date.now() + (response.expires_in * 1000) 
                                                    } 
                                                });
                                                
                                                // ============================================
                                                // ALSO CONNECT TO FIREBASE (properly!)
                                                // ============================================
                                                if (isFirebaseConfigured && firebaseAuth) {
                                                    try {
                                                        console.log('ðŸ”¥ Connecting to Firebase...');
                                                        
                                                        const gUserId = user.id; // Google's unique user ID
                                                        setGoogleUserId(gUserId); // Save to state for debug panel
                                                        console.log('Google User ID:', gUserId);
                                                        
                                                        // STEP 1: Check local storage for mapping
                                                        const storedMapping = await DB.get('settings', 'firebaseUidMapping');
                                                        let firebaseUid = storedMapping?.value?.[gUserId];
                                                        
                                                        // STEP 2: If not found locally, check Firebase database
                                                        if (!firebaseUid) {
                                                            console.log('No local mapping found, checking Firebase...');
                                                            console.log('Looking for path: googleIdMapping/' + gUserId);
                                                            try {
                                                                const mappingRef = firebaseDB.ref(`googleIdMapping/${gUserId}`);
                                                                console.log('Firebase ref created, fetching data...');
                                                                const mappingSnapshot = await mappingRef.once('value');
                                                                console.log('Snapshot received, checking value...');
                                                                const mappingData = mappingSnapshot.val();
                                                                console.log('Mapping data from Firebase:', mappingData);
                                                                
                                                                if (mappingData && mappingData.firebaseUid) {
                                                                    firebaseUid = mappingData.firebaseUid;
                                                                    console.log('âœ… Found Firebase UID in database:', firebaseUid);
                                                                    
                                                                    // Save to local storage for next time
                                                                    const mapping = storedMapping?.value || {};
                                                                    mapping[gUserId] = firebaseUid;
                                                                    await DB.save('settings', { 
                                                                        key: 'firebaseUidMapping', 
                                                                        value: mapping 
                                                                    });
                                                                    console.log('âœ… Saved mapping to local storage');
                                                                } else {
                                                                    console.log('âŒ No mapping found in Firebase (mappingData is null or missing firebaseUid)');
                                                                }
                                                            } catch (error) {
                                                                console.error('âŒ Error checking Firebase mapping:', error);
                                                                console.error('Error details:', error.message, error.code);
                                                            }
                                                        }
                                                        
                                                        if (firebaseUid) {
                                                            // User has signed in before - use existing UID
                                                            console.log('Using existing Firebase UID for this Google account:', firebaseUid);
                                                            
                                                            // Sign in anonymously (will get a new UID, but we'll use the mapping)
                                                            await firebaseAuth.signInAnonymously();
                                                            
                                                            // Use the stored UID for data paths
                                                            setFirebaseUserId(firebaseUid);
                                                            console.log('âœ… Restored Firebase session with UID:', firebaseUid);
                                                            
                                                        } else {
                                                            // First time signing in with this Google account
                                                            console.log('First time sign-in for this Google account');
                                                            
                                                            // Sign in anonymously to get a Firebase UID
                                                            const firebaseResult = await firebaseAuth.signInAnonymously();
                                                            const firebaseUser = firebaseResult.user;
                                                            firebaseUid = firebaseUser.uid;
                                                            
                                                            console.log('âœ… New Firebase UID created:', firebaseUid);
                                                            
                                                            // Store the mapping: Google ID -> Firebase UID
                                                            const mapping = storedMapping?.value || {};
                                                            mapping[gUserId] = firebaseUid;
                                                            await DB.save('settings', { 
                                                                key: 'firebaseUidMapping', 
                                                                value: mapping 
                                                            });
                                                            console.log('âœ… Saved mapping to local IndexedDB');
                                                            
                                                            // Store BOTH directions in Firebase for secure validation
                                                            // 1. Google ID â†’ Firebase UID (for device lookup)
                                                            console.log('ðŸ“¤ Writing mapping to Firebase: googleIdMapping/' + gUserId);
                                                            await firebaseDB.ref(`googleIdMapping/${gUserId}`).set({
                                                                firebaseUid: firebaseUid,
                                                                createdAt: Date.now()
                                                                // NO email/name for privacy!
                                                            });
                                                            console.log('âœ… Wrote googleIdMapping to Firebase');
                                                            
                                                            // 2. Firebase UID â†’ Google ID (for security rules validation)
                                                            console.log('ðŸ“¤ Writing userAuth mapping to Firebase');
                                                            await firebaseDB.ref(`userAuth/${firebaseUid}`).set({
                                                                googleId: gUserId,
                                                                createdAt: Date.now()
                                                            });
                                                            console.log('âœ… Wrote userAuth to Firebase');
                                                            
                                                            setFirebaseUserId(firebaseUid);
                                                            
                                                            // Migrate local playlists to Firebase
                                                            console.log('ðŸ“¤ Migrating playlists to Firebase...');
                                                            let migratedCount = 0;
                                                            
                                                            for (const playlist of playlists) {
                                                                const playlistId = `pl_${playlist.id}`;
                                                                
                                                                await FirebaseDB.savePlaylist(firebaseUid, playlistId, {
                                                                    name: playlist.name,
                                                                    createdAt: playlist.createdAt || Date.now()
                                                                });
                                                                
                                                                for (let i = 0; i < playlist.songs.length; i++) {
                                                                    const song = playlist.songs[i];
                                                                    await FirebaseDB.saveSong(firebaseUid, playlistId, song.id, {
                                                                        name: song.name,
                                                                        driveFileId: song.driveFileId || null,
                                                                        isUrl: song.isUrl || false,
                                                                        url: song.url || null,
                                                                        position: i,
                                                                        createdAt: Date.now()
                                                                    });
                                                                }
                                                                migratedCount++;
                                                            }
                                                            
                                                            console.log(`âœ… Migrated ${migratedCount} playlists to Firebase`);
                                                        }
                                                        
                                                        alert(`âœ… Signed in as ${user.name}!\n\nðŸ”¥ Real-time sync active!\nðŸ“± Your music will sync across all devices with this Google account!`);
                                                        
                                                    } catch (firebaseError) {
                                                        console.error('Firebase connection error:', firebaseError);
                                                        setFirebaseError(firebaseError.message); // Save error for debug panel
                                                        // Continue anyway - Google Drive still works
                                                        alert(`âœ… Signed in to Google Drive as ${user.name}!\n\nâš ï¸ Firebase sync unavailable (${firebaseError.message})\n\nGoogle Drive sync will still work.`);
                                                    }
                                                } else {
                                                    // Firebase not configured - just Google Drive
                                                    alert(`âœ… Signed in as ${user.name}!\n\nYou can now sync your music via Google Drive.`);
                                                }
                                            }
                                        });
                                        
                                        tokenClient.requestAccessToken();
                                    },          
                                    className: 'btn-primary',
                                    style: { width: '100%', fontSize: '13px', padding: '12px 20px', marginBottom: '12px' }
                                }, t.signIn),
                                
                                // Description below
                                React.createElement('div', { style: { fontSize: '14px', lineHeight: '1.5', textAlign: 'center', opacity: 0.8 } }, 
                                    isFirebaseConfigured ? 
                                        t.signInDescription 
                                        : 
                                        'Sign in to sync your music library via Google Drive'
                                )
                            )
                        )
                    ),
                    
                    // Main Content Area
                    React.createElement('div', { className: 'main' },
                        // Mobile header
                        React.createElement('div', { className: `mobile-header ${card}` },
                            React.createElement('button', { 
                                onClick: () => setSidebarOpen(true),
                                className: 'icon-btn icon-btn-small'
                            }, React.createElement(Icons.Menu)),
                            React.createElement('div', { 
                                className: 'font-bold text-xl truncate',
                                className: 'text-color'
                            }, current?.name || 'Music Player')
                        ),
                        
                        // Main content with grid + recent playlist
                        React.createElement('div', { className: 'p-8' },
                            // Playlist Grid
                            React.createElement('div', { 
                                className: 'mb-8',
                                style: { display: view === 'home' ? 'block' : 'none' }
                            },
                                // Search Bar
                                React.createElement('input', {
                                    type: 'search',
                                    placeholder: t.searchPlaceholder,
                                    value: searchQuery,
                                    onChange: (e) => setSearchQuery(e.target.value),
                                    style: { marginBottom: '16px' }
                                }),
                                
                                // Create New Playlist Button
                                React.createElement('button', {
                                    onClick: createPlaylist,
                                    className: 'btn-primary',
                                    style: { marginBottom: '24px', width: '100%' }
                                }, t.createNewPlaylist),
                                
                                React.createElement('div', { 
                                    className: 'text-2xl font-bold mb-4',
                                    className: 'text-color'
                                }, language === 'zh' ? 'æ‚¨çš„æ’­æ”¾æ¸…å–®' : 'Your Playlists'),
                                React.createElement('div', { className: 'playlist-grid' },
                                    filtered.map((p, index) => React.createElement('div', {
                                        key: p.id,
                                        draggable: true,
                                        onDragStart: (e) => handlePlaylistDragStart(e, index),
                                        onDragOver: (e) => handlePlaylistDragOver(e, index),
                                        onDragEnd: handlePlaylistDragEnd,
                                        onClick: () => openPlaylist(p.id),
                                        className: `playlist-grid-card ${card} ${draggedPlaylist === index ? 'dragging' : ''}`,
                                        style: { 
                                            ...(activePlaylist === p.id ? { 
                                                borderColor: PRIMARY,
                                                borderWidth: '2px',
                                                borderStyle: 'solid'
                                            } : {}),
                                            cursor: 'grab'
                                        }
                                    },
                                        React.createElement('button', {
                                            className: 'grid-menu-btn icon-btn icon-btn-small',
                                            onClick: (e) => {
                                                e.stopPropagation();
                                                setContextMenu({
                                                    x: e.clientX - 160,
                                                    y: e.clientY,
                                                    playlist: p
                                                });
                                            }
                                        }, React.createElement(Icons.MoreVertical)),
                                        React.createElement('div', { 
                                            style: { 
                                                fontSize: '48px', 
                                                marginBottom: '12px'
                                            } 
                                        }, React.createElement(Icons.Music)),
                                        React.createElement('div', { 
                                            className: 'font-bold truncate text-color',
                                            style: { marginBottom: '4px' }
                                        }, p.name),
                                        React.createElement('div', { 
                                            className: 'text-sm text-muted'
                                        }, `${p.songs.length} ${t.tracks}`)
                                    )),
                                    
                                    // Empty state when no playlists
                                    filtered.length === 0 && React.createElement('div', {
                                        style: {
                                            textAlign: 'center',
                                            padding: '60px 20px',
                                            color: darkMode ? '#b3b3b3' : '#6b7280'
                                        }
                                    },
                                        React.createElement('div', { 
                                            style: { fontSize: '20px', fontWeight: '600', marginBottom: '12px' }
                                        }, 'No playlists yet'),
                                        React.createElement('div', { 
                                            style: { fontSize: '15px', marginBottom: '32px', opacity: 0.8 }
                                        }, searchQuery ? 'No results found' : 'Click "Create New Playlist" to get started'),
                                        
                                        // Guest mode warning (only show if NOT signed in)
                                        !isSignedIn && React.createElement('div', {
                                            className: 'guest-warning-box',
                                            style: {
                                                padding: '20px 24px',
                                                marginTop: '32px',
                                                background: darkMode ? 'rgba(245, 158, 11, 0.1)' : 'rgba(245, 158, 11, 0.08)',
                                                border: `1px solid ${darkMode ? 'rgba(245, 158, 11, 0.3)' : 'rgba(245, 158, 11, 0.2)'}`,
                                                borderRadius: '12px',
                                                color: darkMode ? '#fbbf24' : '#d97706',
                                                textAlign: 'left',
                                                maxWidth: '700px',
                                                width: '100%',
                                                margin: '32px auto 0',
                                                boxSizing: 'border-box'
                                            }
                                        },
                                            // Title
                                            React.createElement('div', {
                                                style: {
                                                    fontSize: '16px',
                                                    fontWeight: '700',
                                                    marginBottom: '16px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '8px'
                                                }
                                            }, t.guestModeTitle),
                                            
                                            // Subtitle with icon
                                            React.createElement('div', {
                                                style: {
                                                    fontSize: '14px',
                                                    marginBottom: '10px',
                                                    display: 'flex',
                                                    alignItems: 'flex-start',
                                                    gap: '8px'
                                                }
                                            },
                                                React.createElement('span', { 
                                                    style: { fontSize: '18px', flexShrink: 0 } 
                                                }, 'â„¹ï¸'),
                                                React.createElement('span', {}, t.guestModeSubtitle)
                                            ),
                                            
                                            // Bullet points
                                            React.createElement('div', {
                                                style: {
                                                    fontSize: '14px',
                                                    lineHeight: '1.8',
                                                    marginLeft: '26px',
                                                    marginBottom: '16px'
                                                }
                                            },
                                                React.createElement('div', { style: { marginBottom: '6px' } }, 
                                                    `â€¢ ${t.guestModeBullet1}`
                                                ),
                                                React.createElement('div', { style: { marginBottom: '6px' } }, 
                                                    `â€¢ ${t.guestModeBullet2}`
                                                ),
                                                React.createElement('div', {}, 
                                                    `â€¢ ${t.guestModeBullet3}`
                                                )
                                            ),
                                            
                                            // Separator
                                            React.createElement('div', {
                                                style: {
                                                    height: '1px',
                                                    background: darkMode ? 'rgba(245, 158, 11, 0.2)' : 'rgba(245, 158, 11, 0.15)',
                                                    margin: '16px 0'
                                                }
                                            }),
                                            
                                            // Tip
                                            React.createElement('div', {
                                                style: {
                                                    fontSize: '13px',
                                                    lineHeight: '1.5',
                                                    opacity: 0.9
                                                }
                                            }, t.guestModeTip)
                                        )
                                    )
                                )
                            ),
                            
                            // Current/Recent Playlist View
                            current && React.createElement('div', { 
                                style: { 
                                    display: view === 'playlist' ? 'block' : 'none',
                                    position: 'relative'
                                }
                            },
                                // Drag-drop overlay (only shows when dragging AND in playlist view)
                                isDragging && view === 'playlist' && React.createElement('div', {
                                    style: {
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        background: darkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(100, 150, 255, 0.08)',
                                        backdropFilter: 'blur(8px)',
                                        border: `3px dashed ${darkMode ? 'rgba(255, 255, 255, 0.4)' : 'rgba(100, 150, 255, 0.5)'}`,
                                        borderRadius: '16px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        zIndex: 100,
                                        pointerEvents: 'none',
                                        animation: 'pulse 2s ease-in-out infinite'
                                    }
                                },
                                    React.createElement('div', {
                                        style: {
                                            textAlign: 'center',
                                            padding: '40px',
                                            background: darkMode ? 'rgba(40, 40, 50, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                            borderRadius: '12px',
                                            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)',
                                            border: darkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(0, 0, 0, 0.1)'
                                        }
                                    },
                                        React.createElement('div', { 
                                            style: { fontSize: '48px', marginBottom: '16px' } 
                                        }, 'ðŸ“'),
                                        React.createElement('div', { 
                                            style: { 
                                                fontSize: '20px', 
                                                fontWeight: 'bold',
                                                color: darkMode ? '#ffffff' : '#333333',
                                                marginBottom: '8px'
                                            } 
                                        }, t.dropFiles),
                                        React.createElement('div', { 
                                            style: { 
                                                fontSize: '14px',
                                                opacity: 0.7,
                                                color: darkMode ? '#ffffff' : '#666666'
                                            } 
                                        }, current.name)
                                    )
                                ),
                                
                                React.createElement('div', { className: 'flex items-center justify-between mb-6' },
                                    React.createElement('div', { className: 'flex items-center gap-4', style: { flex: 1 } },
                                        React.createElement('button', {
                                            onClick: goToHome,
                                            className: 'icon-btn',
                                            title: 'Back to Home'
                                        }, React.createElement(Icons.ArrowLeft)),
                                        React.createElement('div', { style: { flex: 1 } },
                                            editingPlaylist === current.id ?
                                            React.createElement('input', {
                                                type: 'text',
                                                value: editingPlaylistName,
                                                onChange: (e) => setEditingPlaylistName(e.target.value),
                                                onKeyDown: (e) => {
                                                    if (e.key === 'Enter') saveEditingPlaylist();
                                                    if (e.key === 'Escape') cancelEditingPlaylist();
                                                },
                                                onBlur: saveEditingPlaylist,
                                                autoFocus: true,
                                                className: 'song-name-edit',
                                                style: { fontSize: '30px', marginBottom: '8px' },
                                                onClick: (e) => e.stopPropagation()
                                            })
                                        :
                                            React.createElement('div', {
                                                onTouchStart: () => handlePlaylistLongPressStart(current),
                                                onTouchEnd: handlePlaylistLongPressEnd,
                                                onTouchMove: handlePlaylistLongPressEnd
                                            },
                                                React.createElement('div', { 
                                                    className: 'flex items-center gap-3 mb-2'
                                                },
                                                    React.createElement('div', {
                                                        className: 'text-3xl font-bold text-color'
                                                    }, current.name),
                                                    React.createElement('button', {
                                                        onClick: (e) => {
                                                            e.stopPropagation();
                                                            startEditingPlaylist(current);
                                                        },
                                                        className: 'icon-btn icon-btn-small',
                                                        title: 'Edit playlist name'
                                                    }, React.createElement(Icons.Edit))
                                                ),
                                                React.createElement('div', { 
                                                    className: 'text-muted'
                                                }, `${current.songs.length} ${t.tracks}`)
                                            )
                                        )
                                    ),
                                    React.createElement('button', {
                                        className: 'icon-btn',
                                        onClick: (e) => {
                                            e.stopPropagation();
                                            setContextMenu({
                                                x: e.clientX - 160,
                                                y: e.clientY,
                                                playlist: current
                                            });
                                        }
                                    }, React.createElement(Icons.MoreVertical))
                                ),
                                
                                // Action buttons
                                React.createElement('div', { 
                                    className: 'flex gap-4 mb-6',
                                    style: { flexWrap: 'wrap' }
                                },
                                    React.createElement('button', { 
                                        onClick: () => fileInputRef.current?.click(), 
                                        className: 'btn-primary',
                                        style: { display: 'flex', alignItems: 'center', gap: '8px' }
                                    }, 
                                        React.createElement(Icons.Upload),
                                        'Add Songs'
                                    ),
                                    React.createElement('button', { 
                                        onClick: () => { 
                                            setModalInput(''); 
                                            setShowModal('url'); 
                                        }, 
                                        className: 'btn-secondary',
                                        style: { display: 'flex', alignItems: 'center', gap: '8px' }
                                    }, 
                                        React.createElement(Icons.Link),
                                        t.addUrl
                                    )
                                ),
                                
                                // Song list - EDITABLE
                                current.songs.length > 0 ? current.songs.map((s, i) => 
                                    React.createElement('div', {
                                        key: s.id,
                                        draggable: editingSong !== s.id,
                                        onDragStart: (e) => editingSong !== s.id && handleSongDragStart(e, i),
                                        onDragOver: (e) => editingSong !== s.id && handleSongDragOver(e, i),
                                        onDragEnd: handleSongDragEnd,
                                        onClick: () => editingSong !== s.id && playSong(s, current.id),
                                        className: `song-item ${card} ${currentSong?.id === s.id ? 'active' : ''} ${draggedSong === i ? 'dragging' : ''}`,
                                        style: { 
                                            marginBottom: '8px',
                                            ...(currentSong?.id === s.id ? { background: `${PRIMARY}20` } : {})
                                        }
                                    },
                                        React.createElement('div', { 
                                            className: 'drag-handle',
                                            onTouchStart: (e) => editingSong !== s.id && handleSongTouchStart(e, i),
                                            onTouchMove: (e) => editingSong !== s.id && handleSongTouchMove(e, i),
                                            onTouchEnd: handleSongTouchEnd
                                        }, React.createElement(Icons.GripVertical)),
                                        React.createElement('div', { style: { flex: 1, minWidth: 0 } },
                                            editingSong === s.id ?
                                                React.createElement('input', {
                                                    type: 'text',
                                                    value: editingSongName,
                                                    onChange: (e) => setEditingSongName(e.target.value),
                                                    onKeyDown: (e) => {
                                                        if (e.key === 'Enter') saveEditingSong();
                                                        if (e.key === 'Escape') cancelEditingSong();
                                                    },
                                                    onBlur: saveEditingSong,
                                                    autoFocus: true,
                                                    className: 'song-name-edit',
                                                    onClick: (e) => e.stopPropagation()
                                                })
                                            :
                                                React.createElement('div', null,
                                                    React.createElement('div', { 
                                                        className: 'font-bold truncate text-color', 
                                                        style: currentSong?.id === s.id ? { color: PRIMARY } : {}
                                                    }, s.name),
                                                    React.createElement('div', { 
                                                        className: 'text-sm text-muted'
                                                    }, s.isUrl ? t.streaming : t.local)
                                                )
                                        ),
                                        editingSong !== s.id && React.createElement('button', {
                                            onClick: (e) => {
                                                e.stopPropagation();
                                                startEditingSong(s);
                                            },
                                            className: 'icon-btn icon-btn-small',
                                            title: 'Edit song name'
                                        }, React.createElement(Icons.Edit)),
                                        React.createElement('button', {
                                            onClick: (e) => { 
                                                e.stopPropagation(); 
                                                setShowModal({ type: 'delete-song', id: s.id, pid: current.id }); 
                                            },
                                            className: 'icon-btn icon-btn-small',
                                            style: { flexShrink: 0 }
                                        }, React.createElement(Icons.Trash))
                                    )
                                ) : React.createElement('div', { 
                                    style: { 
                                        textAlign: 'center', 
                                        padding: '80px 20px',
                                        color: '#b3b3b3'
                                    }
                                },
                                    React.createElement('div', { className: 'text-xl mb-2' }, t.noTracksYet),
                                    React.createElement('div', {}, t.uploadOrAdd)
                                )
                            )
                        )
                    )
                ),
                
                // MODALS
                
                // Create Playlist Modal
                showModal === 'create' && React.createElement('div', { 
                    className: 'modal-overlay',
                    onClick: (e) => {
                        if (e.target === e.currentTarget) setShowModal(null);
                    }
                },
                    React.createElement('div', { className: `modal ${modalClass}` },
                        React.createElement('div', { 
                            className: 'text-2xl font-bold mb-4' 
                        }, t.createPlaylist),
                        React.createElement('input', {
                            type: 'text',
                            value: modalInput,
                            onChange: (e) => setModalInput(e.target.value),
                            placeholder: t.playlistName,
                            className: 'mb-4',
                            onKeyPress: (e) => e.key === 'Enter' && handleCreate(),
                            autoFocus: true,
                            style: {
                                background: darkMode ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.05)',
                                border: `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                color: darkMode ? '#fff' : '#1a1a1a'
                            }
                        }),
                        React.createElement('div', { 
                            className: 'flex gap-3', 
                            style: { justifyContent: 'flex-end' } 
                        },
                            React.createElement('button', { 
                                onClick: () => setShowModal(null), 
                                className: 'btn-secondary',
                                style: { color: darkMode ? '#ffffff' : '#000000' }
                            }, t.cancel),
                            React.createElement('button', { 
                                onClick: handleCreate, 
                                className: 'btn-primary' 
                            }, t.create)
                        )
                    )
                ),
                
                // Add URL Modal
                showModal === 'url' && React.createElement('div', { 
                    className: 'modal-overlay',
                    onClick: (e) => {
                        if (e.target === e.currentTarget) setShowModal(null);
                    }
                },
                    React.createElement('div', { className: `modal ${modalClass}` },
                        React.createElement('div', { 
                            className: 'text-2xl font-bold mb-4' 
                        }, t.addStreamingUrl),
                        React.createElement('input', {
                            type: 'text',
                            value: modalInput,
                            onChange: (e) => setModalInput(e.target.value),
                            placeholder: 'https://example.com/audio.mp3',
                            className: 'mb-4',
                            onKeyPress: (e) => e.key === 'Enter' && handleUrlSubmit(),
                            autoFocus: true,
                            style: {
                                background: darkMode ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.05)',
                                border: `1px solid ${darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'}`,
                                color: darkMode ? '#fff' : '#1a1a1a'
                            }
                        }),
                        React.createElement('div', { 
                            className: 'flex gap-3', 
                            style: { justifyContent: 'flex-end' } 
                        },
                            React.createElement('button', { 
                                onClick: () => setShowModal(null), 
                                className: 'btn-secondary',
                                style: { color: darkMode ? '#ffffff' : '#000000' }
                            }, t.cancel),
                            React.createElement('button', { 
                                onClick: handleUrlSubmit, 
                                className: 'btn-primary' 
                            }, t.add)
                        )
                    )
                ),
                
                // Export/Import Modal
                showModal === 'export' && React.createElement('div', { 
                    className: 'modal-overlay',
                    onClick: (e) => {
                        if (e.target === e.currentTarget) setShowModal(null);
                    }
                },
                    React.createElement('div', { className: `modal ${modalClass}` },
                        React.createElement('div', { 
                            className: 'text-2xl font-bold mb-6' 
                        }, t.backupShareTitle),
                        React.createElement('button', { 
                            onClick: () => { 
                                exportData(); 
                                setShowModal(null); 
                            }, 
                            className: 'btn-primary mb-4', 
                            style: { width: '100%' } 
                        }, t.exportPlaylists),
                        React.createElement('input', { 
                            type: 'file', 
                            accept: '.json', 
                            onChange: importData, 
                            id: 'import-file', 
                            style: { display: 'none' } 
                        }),
                        React.createElement('label', { 
                            htmlFor: 'import-file', 
                            className: 'btn-secondary mb-4', 
                            style: { 
                                width: '100%', 
                                display: 'block', 
                                textAlign: 'center',
                                cursor: 'pointer',
                                color: darkMode ? '#ffffff' : '#000000'
                            } 
                        }, t.importPlaylists),
                        React.createElement('button', { 
                            onClick: () => setShowModal(null), 
                            style: { 
                                width: '100%', 
                                background: 'none', 
                                border: 'none', 
                                cursor: 'pointer', 
                                padding: '12px',
                                fontSize: '14px',
                                color: '#b3b3b3'
                            } 
                        }, t.close)
                    )
                ),
                
                // Delete Playlist Confirmation
                showModal?.type === 'delete-playlist' && React.createElement('div', { 
                    className: 'modal-overlay',
                    onClick: (e) => {
                        if (e.target === e.currentTarget) setShowModal(null);
                    }
                },
                    React.createElement('div', { className: `modal ${modalClass}` },
                        React.createElement('div', { 
                            className: 'text-xl font-bold mb-4' 
                        }, t.deletePlaylist),
                        React.createElement('div', { 
                            className: `mb-6`,
                            style: { color: '#b3b3b3' }
                        }, t.deletePlaylistMsg),
                        React.createElement('div', { 
                            className: 'flex gap-3', 
                            style: { justifyContent: 'flex-end' } 
                        },
                            React.createElement('button', { 
                                onClick: () => setShowModal(null), 
                                className: 'btn-secondary',
                                style: { color: darkMode ? '#ffffff' : '#000000' }
                            }, t.cancel),
                            React.createElement('button', { 
                                onClick: () => deletePlaylist(showModal.id), 
                                style: { 
                                    background: '#dc2626', 
                                    border: 'none', 
                                    color: 'white', 
                                    padding: '12px 28px', 
                                    borderRadius: '50px', 
                                    fontWeight: '600', 
                                    cursor: 'pointer',
                                    fontSize: '15px'
                                } 
                            }, t.delete)
                        )
                    )
                ),
                
                // Delete Song Confirmation Modal
                showModal?.type === 'delete-song' && React.createElement('div', { 
                    className: 'modal-overlay',
                    onClick: (e) => {
                        if (e.target === e.currentTarget) setShowModal(null);
                    }
                },
                    React.createElement('div', { className: `modal ${modalClass}` },
                        React.createElement('div', { 
                            className: 'text-xl font-bold mb-4' 
                        }, t.deleteTrack),
                        React.createElement('div', { 
                            className: `mb-6`,
                            style: { color: '#b3b3b3' }
                        }, t.deleteTrackMsg),
                        React.createElement('div', { 
                            className: 'flex gap-3', 
                            style: { justifyContent: 'flex-end' } 
                        },
                            React.createElement('button', { 
                                onClick: () => setShowModal(null), 
                                className: 'btn-secondary',
                                style: { color: darkMode ? '#ffffff' : '#000000' }
                            }, t.cancel),
                            React.createElement('button', { 
                                onClick: () => deleteSong(showModal.id, showModal.pid), 
                                style: { 
                                    background: '#dc2626', 
                                    border: 'none', 
                                    color: 'white', 
                                    padding: '12px 28px', 
                                    borderRadius: '50px', 
                                    fontWeight: '600', 
                                    cursor: 'pointer',
                                    fontSize: '15px'
                                } 
                            }, 'Delete')
                        )
                    )
                ),
                
                // PLAYER BAR (IMPROVED)
                currentSong && React.createElement('div', { className: `player ${card}` },
                    // Song info and time
                    React.createElement('div', { 
                        className: 'player-info'
                    },
                        React.createElement('div', { 
                            className: 'font-bold truncate', 
                            style: { 
                                flex: 1, 
                                minWidth: '120px',
                                color: darkMode ? '#ffffff' : '#ffffff'
                            } 
                        }, currentSong.name),
                        React.createElement('div', { 
                            style: { 
                                fontSize: '13px', 
                                flexShrink: 0,
                                color: darkMode ? '#b3b3b3' : '#ffffff'
                            }
                        }, formatTime(audioRef.current?.currentTime))
                    ),
                    
                    // Progress bar
                    React.createElement('div', {
                        className: 'progress-bar',
                        style: { marginBottom: '10px' },
                        onClick: (e) => {
                            const rect = e.currentTarget.getBoundingClientRect();
                            const pos = (e.clientX - rect.left) / rect.width;
                            if (audioRef.current && audioRef.current.duration) {
                                audioRef.current.currentTime = pos * audioRef.current.duration;
                            }
                        }
                    },
                        React.createElement('div', { 
                            className: 'progress-fill', 
                            style: { width: `${progress}%` } 
                        })
                    ),
                    
                    // Controls layout
                    React.createElement('div', { 
                        className: 'player-main'
                    },
                        // Playback controls (centered)
                        React.createElement('div', { className: 'player-controls' },
                            React.createElement('button', {
                                onClick: playPrevious,
                                className: 'icon-btn',
                                title: 'Previous'
                            }, React.createElement(Icons.SkipBack)),
                            React.createElement('button', {
                                onClick: () => setIsPlaying(!isPlaying),
                                className: 'icon-btn',
                                style: { 
                                    background: PRIMARY,
                                    borderColor: PRIMARY
                                },
                                title: isPlaying ? 'Pause' : 'Play'
                            }, isPlaying ? React.createElement(Icons.Pause) : React.createElement(Icons.Play)),
                            React.createElement('button', {
                                onClick: playNext,
                                className: 'icon-btn',
                                title: 'Next'
                            }, React.createElement(Icons.SkipForward)),
                            React.createElement('button', {
                                onClick: () => setRepeat(!repeat),
                                className: 'icon-btn',
                                style: { 
                                    opacity: repeat ? 1 : 0.5,
                                    color: repeat ? PRIMARY : '#ffffff'
                                },
                                title: 'Repeat'
                            }, React.createElement(Icons.Repeat))
                        ),
                        // Volume controls (desktop only)
                        React.createElement('div', { 
                            className: 'flex items-center gap-3 hide-mobile' 
                        },
                            React.createElement('div', {
                                style: { color: darkMode ? '#ffffff' : '#ffffff' }
                            }, React.createElement(Icons.Volume)),
                            React.createElement('input', {
                                type: 'range',
                                min: 0,
                                max: 100,
                                value: volume,
                                onChange: (e) => setVolume(Number(e.target.value)),
                                style: { width: '100px' }
                            }),
                            React.createElement('span', { 
                                style: { 
                                    minWidth: '40px', 
                                    fontSize: '14px', 
                                    color: darkMode ? '#b3b3b3' : '#ffffff'
                                }
                            }, `${volume}%`)
                        )
                    )
                )
            );
        }

        // Reset viewport zoom on load (mobile fix)
        if ('visualViewport' in window) {
            const resetViewport = () => {
                const viewport = document.querySelector('meta[name="viewport"]');
                if (viewport && window.visualViewport.scale !== 1) {
                    viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
                }
            };
            window.visualViewport.addEventListener('resize', resetViewport);
            window.visualViewport.addEventListener('scroll', resetViewport);
        }
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MusicPlayer));
    </script>
</body>
</html>
